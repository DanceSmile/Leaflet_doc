<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>API</title>
    <link rel="stylesheet" type="text/css" href="style.css"/>
</head>
<body>

<div class="container">

<h1><img src="oceanjs.png"></h1>

<div id="toc" class="clearfix">
    <div class="span-4 first">
        <h4>Quick Start</h4>
        <ul>
            <li><a href="#quick-start">示例</a></li>
        </ul>
    </div>

    <div class="span-4">
        <h4>Map</h4>
        <ul>
            <li><a href="#map-constructor">Constructor</a></li>
            <li><a href="#map-options">Options</a></li>
            <li><a href="#map-events">Events</a></li>
        </ul>
        <h4>Map Methods</h4>
        <ul>
            <li><a href="#map-set-methods">For modifying map state</a></li>
            <li><a href="#map-get-methods">For getting map state</a></li>
            <li><a href="#map-stuff-methods">For layers and controls</a></li>
            <li><a href="#map-conversion-methods">Conversion methods</a></li>
            <li><a href="#map-misc-methods">Other methods</a></li>
        </ul>
        <h4>Map Misc</h4>
        <ul>
            <li><a href="#map-properties">Properties</a></li>
            <li><a href="#map-panes">Panes</a></li>
        </ul>
    </div>
    <div class="span-4">
        <h4>UI Layers</h4>
        <ul>
            <li><a href="#marker">Marker</a></li>
            <li><a href="#popup">Popup</a></li>
        </ul>
        <h4>Raster Layers</h4>
        <ul>
            <li><a href="#tilelayer">TileLayer</a></li>
            <li><a href="#tilelayer-wms">TileLayer.WMS</a></li>
            <li><a href="#tilelayer-canvas">TileLayer.Canvas</a></li>
            <li><a href="#imageoverlay">ImageOverlay</a></li>
        </ul>
        <h4>Vector Layers</h4>
        <ul>
            <li><a href="#path">Path</a></li>
            <li><a href="#polyline">Polyline</a></li>
            <li><a href="#multipolyline">MultiPolyline</a></li>
            <li><a href="#polygon">Polygon</a></li>
            <li><a href="#multipolygon">MultiPolygon</a></li>
            <li><a href="#rectangle">Rectangle</a></li>
            <li><a href="#circle">Circle</a></li>
            <li><a href="#circlemarker">CircleMarker</a></li>
        </ul>
    </div>
    <div class="span-4">
        <h4>Other Layers</h4>
        <ul>
            <li><a href="#layergroup">LayerGroup</a></li>
            <li><a href="#featuregroup">FeatureGroup</a></li>
            <li><a href="#geojson">GeoJSON</a></li>
        </ul>
        <h4>Basic Types</h4>
        <ul>
            <li><a href="#latlng">LatLng</a></li>
            <li><a href="#latlngbounds">LatLngBounds</a></li>
            <li><a href="#point">Point</a></li>
            <li><a href="#bounds">Bounds</a></li>
            <li><a href="#icon">Icon</a></li>
            <li><a href="#divicon">DivIcon</a></li>
        </ul>
        <h4>Controls</h4>
        <ul>
            <li><a href="#control">Control</a></li>
            <li><a href="#control-zoom">Zoom</a></li>
            <li><a href="#control-attribution">Attribution</a></li>
            <li><a href="#control-layers">Layers</a></li>
            <li><a href="#control-scale">Scale</a></li>
        </ul>
    </div>
    <div class="span-4">
        <h4>Events</h4>
        <ul>
            <li><a href="#events">Events methods</a></li>
            <li><a href="#event-objects">Event objects</a></li>
        </ul>
        <h4>Utility</h4>
        <ul>
            <li><a href="#class">Class</a></li>
            <li><a href="#browser">Browser</a></li>
            <li><a href="#util">Util</a></li>
            <li><a href="#transformation">Transformation</a></li>
            <li><a href="#lineutil">LineUtil</a></li>
            <li><a href="#polyutil">PolyUtil</a></li>
        </ul>
        <h4>DOM Utility</h4>
        <ul>
            <li><a href="#domevent">DomEvent</a></li>
            <li><a href="#domutil">DomUtil</a></li>
            <li><a href="#posanimation">PosAnimation</a></li>
            <li><a href="#draggable">Draggable</a></li>
        </ul>
    </div>

    <div class="span-4">
        <h4>Services</h4>
        <ul>
            <li><a href="#bussearch">BusSearch</a></li>
            <li><a href="#dailynews">DailyNews</a></li>
            <li><a href="#militarybase">MilitaryBase</a></li>
            <li><a href="#partition">Partition</a></li>
            <li><a href="#poisearch">PoiSearch</a></li>
            <li><a href="#roadsearch">RoadSearch</a></li>
            <li><a href="#routesearch">RouteSearch</a></li>
            <li><a href="#thematic">Thematic</a></li>
        </ul>
    </div>

    <div class="span-4 last">
        <h4>Interfaces</h4>
        <ul>
            <li><a href="#ihandler">IHandler</a></li>
            <li><a href="#ilayer">ILayer</a></li>
            <!--<li><a class="nodocs" href="#">IFeature</a></li>-->
            <li><a href="#icontrol">IControl</a></li>
            <li><a href="#iprojection">IProjection</a></li>
            <li><a href="#icrs">ICRS</a></li>
        </ul>

        <h4>Misc</h4>
        <ul>
            <li><a href="#global">global switches</a></li>
            <li><a href="#noconflict">noConflict</a></li>
            <li><a href="#version">version</a></li>
        </ul>
    </div>
</div>

<h2 id="quick-start">快速开始</h2>

<h4>1.引入CSS文件</h4>

<pre><code class="html">&lt;link rel="stylesheet" href="http://cdn.domain.com/ocean.css" /&gt;<br />&lt;!--[if lte IE 8]&gt;<br />&lt;link rel="stylesheet" href="http://cdn.domain.com/ocean.ie.css" /&gt;<br />&lt;![endif]--&gt;
</code></pre>

<h4>2.引入js文件</h4>

<pre><code class="html">&lt;script src="http://cdn.domain.com/ocean.js"&gt;&lt;/script&gt;
</code></pre>

<h4>3.添加地图HTML容器</h4>

<pre><code class="html">&lt;div id="map"&gt;&lt;/div&gt;
</code></pre>

<h4>4.设置地图容器大小（容器大小不能为0）</h4>

<pre><code class="css">#map { height: 180px; }
</code></pre>

<h4>5.添加地图容器实例到地图HTML容器中</h4>

<pre><code class="javascript">var map = L.map('map').setView([31.50, 116.09], 13);
</code></pre>

<h4>6.添加地图切片</h4>

<pre><code class="javascript">L.tileLayer.provider('ditutongMap.base_street').addTo(map);
</code></pre>


<h2 id="map-class">L.Map</h2>

<h3 id="map-usage">示例</h3>


<pre><code class="javascript">// 初始化地图
    var map = L.map('map', {
    center: [30.002, 116.09],
    zoom: 13
    });</code></pre>

<h3 id="map-constructor" class="left">Constructor（构造器）</h3>

<table>
    <tr>
        <th>构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Map</b>(
            <nobr>&lt;HTMLElement|String&gt; <i>id</i>,</nobr>
            <nobr>&lt;<a href="#map-options">Map options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Map(<span class="comment">&hellip;</span>)</code><br />
            <code>L.map(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>根据给定的参数构造一个L.Map类的新实例。</td>
    </tr>
</table>




<h3 id="map-options">Options（选项）</h3>

<h4>Map State Options（地图状态选项）</h4>

<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>center</b></code></td>
        <td><code><a href="#latlng">LatLng</a></code></td>
        <td><code><span class="literal">null</span></code></td>
        <td>初始化地图的地理中心。</td>
    </tr>
    <tr>
        <td><code><b>zoom</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="literal">null</span></code></td>
        <td>初始化地图的缩放。</td>
    </tr>
    <tr>
        <td><code><b>layers</b></code></td>
        <td><code><a href="#ilayer">ILayer</a>[]</code></td>
        <td><code><span class="literal">null</span></code></td>
        <td>初始化后加载到地图上的图层。</td>
    </tr>
    <tr>
        <td><code><b>minZoom</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="literal">null</span></code></td>
        <td>地图的最小视图。可以通过动态设置 <code>minZoom</code> 来重写当前属性.</td>
    </tr>
    <tr>
        <td><code><b>maxZoom</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="literal">null</span></code></td>
        <td>地图的最大视图。可以通过动态设置 <code>maxZoom</code> 来重写当前属性.</td>
    </tr>
    <tr id="map-maxbounds">
        <td><code><b>maxBounds</b></code></td>
        <td><code><a href="#latlngbounds">LatLngBounds</a></code></td>
        <td><code><span class="literal">null</span></code></td>
        <td>地图限制到给定的地理界限，如需要动态设置，使用 <code>setMaxBounds</code> 方法</td>
    </tr>
    <tr>
        <td><code><b>crs</b></code></td>
        <td><code><a href="#icrs">CRS</a></code></td>
        <td><code>L.CRS.<br/>EPSG3857</code></td>
        <td>使用的坐标系，当你不确定坐标系是什么时请不要更改。</td>
    </tr>
</table>

<h4>Interaction Options（交互操作）</h4>

<table>
    <tr>
        <th class="width140">参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>dragging</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>决定地图是否可被鼠标或触摸拖动。</td>
    </tr>
    <tr>
        <td><code><b>touchZoom</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>决定地图是否可被两只手指触摸拖拽缩放。</td>
    </tr>
    <tr>
        <td><code><b>scrollWheelZoom</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>决定地图是否被被鼠标滚轮滚动缩放。</td>
    </tr>
    <tr>
        <td><code><b>doubleClickZoom</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>决定地图是否可被双击缩放。</td>
    </tr>
    <tr>
        <td><code><b>boxZoom</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>决定地图是否可被缩放到鼠标拖拽出的矩形的视图，鼠标拖拽时需要同时按住shift键。</td>
    </tr>
    <tr>
        <td><code><b>trackResize</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>确定地图在窗口尺寸改变时是否可以自动处理浏览器以更新视图。</td>
    </tr>
    <tr>
        <td><code><b>worldCopyJump</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">false</span></code></td>
        <td>当这个选项可用时，当你平移地图到其另一个领域时会被地图捕获到，并无缝地跳转到原始的领域以保证所有标注、矢量图层之类的覆盖物仍然可见。</td>
    </tr>
    <tr>
        <td><code><b>closePopupOnClick</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>当你不想用户点击地图关闭消息弹出框时，请将其设置为false。</td>
    </tr>
</table>

<h4>Keyboard Navigation Options（键盘操纵选项）</h4>

<table>
    <tr>
        <th class="width140">参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>keyboard</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>键盘操作地图是否有效。true，表示键盘操作有效（默认）；false，表示键盘操作失效。使用键盘工具操作地图，包括通过键盘方向键移动地图、使用主键盘“+”、“-”键来缩放地图</td>
    </tr>
    <tr>
        <td><code><b>keyboardPanOffset</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">80</span></code></td>
        <td>键盘方向键操作地图平移像素值</td>
    </tr>
    <tr>
        <td><code><b>keyboardZoomOffset</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">1</span></code></td>
        <td>通过键盘<code>+</code> 或者 <code>-</code> 的缩放级数</td>
    </tr>
</table>

<h4>Panning Inertia Options（平移惯性选项）</h4>

<table>
    <tr>
        <th class="width140">参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>inertia</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>地图是否具有惯性缓动效果。惯性缓动效果，即地图拖拽后根据惯性滑动小段距离的效果。</td>
    </tr>
    <tr>
        <td><code><b>inertiaDeceleration</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">3000</span></code></td>
        <td>确定惯性移动减速的速率，单位是像素每秒的二次方。</td>
    </tr>
    <tr>
        <td><code><b>inertiaMaxSpeed</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">1500</span></code></td>
        <td>惯性移动的最大速度，单位是像素每秒。</td>
    </tr>
    <tr>
        <td><code><b>inertiaThreshold</b></code></td>
        <td><code>Number</code></td>
        <td><code>depends</code></td>
        <td>放开鼠标或是触摸来停止惯性移动与移动停止之间的毫秒数。</td>
    </tr>
</table>

<h4>Control options（控制选项）</h4>

<table>
    <tr>
        <th class="width140">参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>zoomControl</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>确定缩放控制是否默认加载在地图上。</td>
    </tr>
    <tr>
        <td><code><b>attributionControl</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>确定地图版权属性标识 <a href="#control-attribution">attribution control</a> 是否默认加载在地图上。</td>
    </tr>
</table>

<h4>Animation options（动画选项）</h4>

<table>
    <tr>
        <th class="width140">参数</th>
        <th>类型</th>
        <th>默认</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>fadeAnimation</b></code></td>
        <td><code>Boolean</code></td>
        <td>depends</td>
        <td>确定切片淡出动画是否可用。通常默认在所有浏览器中都支持CSS3转场，android例外。</td>
    </tr>
    <tr>
        <td><code><b>zoomAnimation</b></code></td>
        <td><code>Boolean</code></td>
        <td>depends</td>
        <td>确定切片缩放动画是否可用。通常默认在所有浏览器中都支持CSS3转场，android例外。</td>
    </tr>
    <tr>
        <td><code><b>markerZoomAnimation</b></code></td>
        <td><code>Boolean</code></td>
        <td>depends</td>
        <td>确定注记的缩放是否随地图缩放动画而播放，如果被禁用，注记在动画中拉长时会消失。通常默认在所有浏览器中都支持CSS3转场，android例外。</td>
    </tr>
</table>


<h3 id="map-events">Events（事件）</h3>

<p>You can subscribe to the following events using <a href="#events">these methods</a>.</p>

<table>
    <tr>
        <th>事件</th>
        <th>Data</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>click</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>用户点击或触摸地图时触发。</td>
    </tr>
    <tr>
        <td><code><b>dblclick</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>用户双击或连续两次触摸地图时触发。</td>
    </tr>
    <tr>
        <td><code><b>mousedown</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>用户按下鼠标按键时触发。</td>
    </tr>
    <tr>
        <td><code><b>mouseup</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>用户按下鼠标按键时触发。</td>
    </tr>
    <tr>
        <td><code><b>mouseover</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>鼠标进入地图时触发。</td>
    </tr>
    <tr>
        <td><code><b>mouseout</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>鼠标离开地图时触发。</td>
    </tr>
    <tr>
        <td><code><b>mousemove</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>鼠标在地图上移动时触发。</td>
    </tr>
    <tr>
        <td><code><b>contextmenu</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>当用户在地图上按下鼠标右键时触发，如果有监听器在监听这个时间，则浏览器默认的情景菜单被禁用。</td>
    </tr>
    <tr>
        <td><code><b>focus</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>当用户在地图上进行标引、点击或移动时进行聚焦。</td>
    </tr>
    <tr>
        <td><code><b>blur</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>当地图失去焦点时触发。</td>
    </tr>
    <tr>
        <td><code><b>preclick</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>当鼠标在地图上点击之前触发。有时会在点击鼠标时，并在已存在的点击事件开始处理之前想要某件事情发生时用得到。</td>
    </tr>
    <tr>
        <td><code><b>load</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>当地图初始化时触发。（当地图的中心点和缩放初次设置时）</td>
    </tr>
    <tr id="map-viewreset">
        <td><code><b>viewreset</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>当地图需要重绘内容时触发。（通常在地图缩放和载入时发生）这对于创建用户自定义的叠置图层非常有用。</td>
    </tr>
    <tr>
        <td><code><b>movestart</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>地图视图开始改变时触发。（比如用户开始拖动地图）</td>
    </tr>
    <tr>
        <td><code><b>move</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>所有的地图视图移动时触发。</td>
    </tr>
    <tr id="map-moveend">
        <td><code><b>moveend</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>当地图视图结束改变时触发。（比如用户停止拖动地图）</td>
    </tr>
    <tr>
        <td><code><b>dragstart</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>用户开始拖动地图时触发。</td>
    </tr>
    <tr>
        <td><code><b>drag</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>用户拖动地图时不断重复地触发。</td>
    </tr>
    <tr>
        <td><code><b>dragend</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>用户停止拖动时触发。</td>
    </tr>
    <tr>
        <td><code><b>zoomstart</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>当地图缩放即将发生时触发。（比如缩放动作开始前）</td>
    </tr>
    <tr>
        <td><code><b>zoomend</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>当地图缩放时触发。</td>
    </tr>
    <tr>
        <td><code><b>zoomlevelschange</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>当添加或删除一个图层且缩放等级改变时触发。</td>
    </tr>
    <tr>
        <td><code><b>autopanstart</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>打开弹出窗口时地图开始自动平移时触发。</td>
    </tr>
    <tr>
        <td><code><b>layeradd</b></code></td>
        <td><code><a href="#layer-event">LayerEvent</a></code></td>
        <td>当一个新的图层添加到地图上时触发。</td>
    </tr>
    <tr>
        <td><code><b>layerremove</b></code></td>
        <td><code><a href="#layer-event">LayerEvent</a></code></td>
        <td>当一些图层从地图上移除时触发。</td>
    </tr>
    <tr>
        <td><code><b>baselayerchange</b></code></td>
        <td><code><a href="#layer-event">LayerEvent</a></code>
        <td>当通过图层控制台改变基础图层时触发。</td>
    </tr>
    <tr>
        <td><code><b>overlayadd</b></code></td>
        <td><code><a href="#layer-event">LayerEvent</a></code>
        <td>当一个附加图片层添加时触发。</td>
    </tr>
    <tr>
        <td><code><b>overlayremove</b></code></td>
        <td><code><a href="#layer-event">LayerEvent</a></code>
        <td>当一个附加图片层添加时触发。</td>
    </tr>
    <tr>
        <td><code><b>locationfound</b></code></td>
        <td><code><a href="#location-event">LocationEvent</a></code>
        <td>当地理寻址成功时触发。 (使用 <a href="#map-locate">locate</a> 方法)</td>
    </tr>
    <tr>
        <td><code><b>locationerror</b></code></td>
        <td><code><a href="#error-event">ErrorEvent</a></code>
        <td>当地理寻址错误时触发。 (使用 <a href="#map-locate">locate</a> 方法)</td>
    </tr>
    <tr>
        <td><code><b>popupopen</b></code></td>
        <td><code><a href="#popup-event">PopupEvent</a></code></td>
        <td>当弹出框打开时触发。 (使用 <code>openPopup</code> 方法)</td>
    </tr>
    <tr>
        <td><code><b>popupclose</b></code></td>
        <td><code><a href="#popup-event">PopupEvent</a></code></td>
        <td>当弹出框关闭时触发 (使用 <code>closePopup</code> 方法).</td>
    </tr>
</table>


<h3 id="map-set-methods">Methods for Modifying Map State（地图状态修改）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>setView</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>center</i>,</nobr>
            <nobr>&lt;Number&gt; <i>zoom</i>,</nobr>
            <nobr>&lt;Boolean&gt; <i>forceReset?</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>设定地图（设定其地理中心和缩放），如果<code>forceReset</code>设置的是<code>true</code>，即使移动和缩放动作是合理的，地图也会重载，其默认值是<code>fault</code>。</td>
    </tr>
    <tr>
        <td><code><b>setZoom</b>(
            <nobr>&lt;Number&gt; <i>zoom</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>设定地图的缩放。</td>
    </tr>
    <tr>
        <td><code><b>zoomIn</b>( <nobr>&lt;Number&gt; delta? )</nobr></code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>通过 <code>delta</code> 变量放大地图的级别， (<code><span class="number">1</span></code> 是默认值)。</td>
    </tr>
    <tr>
        <td><code><b>zoomOut</b>( <nobr>&lt;Number&gt; delta? )</nobr></code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>通过 <code>delta</code> 变量缩小地图的级别， (<code><span class="number">1</span></code> 是默认值)。</td>
    </tr>
    <tr id="map-fitbounds">
        <td><code><b>fitBounds</b>(
            <nobr>&lt;<a href="#latlngbounds">LatLngBounds</a>&gt; <i>bounds</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>将地图视图尽可能大地设定在给定的地理边界内。</td>
    </tr>
    <tr id="map-fitworld">
        <td><code><b>fitWorld</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>将地图视图尽可能大地设定在包含全部地域的级别上。</td>
    </tr>
    <tr>
        <td><code><b>panTo</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>将地图平移到给定的中心。如果新的中心点在屏幕内与现有的中心点不同则产生平移动作。</td>
    </tr>
    <tr id="map-paninsidebounds">
        <td><code><b>panInsideBounds</b>(
            <nobr>&lt;<a href="#latlngbounds">LatLngBounds</a>&gt; <i>bounds</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>平移地图到坐落于给定边界最接近的视图内。</td>
    </tr>
    <tr>
        <td><code><b>panBy</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>point</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>通过给定的像素值对地图进行平移。</td>
    </tr>
    <tr>
        <td><code><b>invalidateSize</b>(
            <nobr>&lt;Boolean&gt; <i>animate?</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>检查地图容器的大小是否改变并更新地图，如果是这样的话，在动态改变地图大小后调用，如果<code>animate</code>是<code>true</code>的话，对地图进行更新。</td>
    </tr>
    <tr id="map-setmaxbounds">
        <td><code><b>setMaxBounds</b>(
            <nobr>&lt;<a href="#latlngbounds">LatLngBounds</a>&gt; <i>bounds</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>将地图限定在给定的边界内。 ( <a href="#map-maxbounds">map maxBounds</a> )</td>
    </tr>
    <tr id="map-locate">
        <td><code><b>locate</b>(
            <nobr>&lt;<a href="#map-locate-options">Locate options</a>&gt; <i>options?</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>用地理定位接口获取用户位置信息，在成功定位或定位出错产生<code>locationerror</code>后解除<code>location-found</code>事件与定位数据，且将地图视图设定到检测的确切的用户的位置（如果定位失败则回到地域视图）。在Location Options中有更多详细内容。 在 <a href="#map-locate-options">Locate options</a> 中有更多详细内容。</td>
    </tr>
    <tr>
        <td><code><b>stopLocate</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>开始 <code><b>map.locate</b>({watch: true})</code> 方法时停止预先检测位置信息。</td>
    </tr>
</table>

<h3 id="map-get-methods">Methods for Getting Map State（获取地图状态）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>getCenter</b>()</code></td>
        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>返回地图视图的地理中心。</td>
    </tr>
    <tr>
        <td><code><b>getZoom</b>()</code></td>
        <td><code>Number</code></td>
        <td>获取地图视图现在所处的缩放级别。</td>
    </tr>
    <tr>
        <td><code><b>getMinZoom</b>()</code></td>
        <td><code>Number</code></td>
        <td>返回地图最小的缩放级别。</td>
    </tr>
    <tr>
        <td><code><b>getMaxZoom</b>()</code></td>
        <td><code>Number</code></td>
        <td>返回地图最大的缩放级别。</td>
    </tr>
    <tr>
        <td><code><b>getBounds</b>()</code></td>
        <td><code><a href="#latlngbounds">LatLngBounds</a></code></td>
        <td>返回地图视图的经纬度边界。</td>
    </tr>
    <tr>
        <td><code><b>getBoundsZoom</b>(
            <nobr>&lt;<a href="#latlngbounds">LatLngBounds</a>&gt; <i>bounds</i>,</nobr>
            <nobr>&lt;Boolean&gt; <i>inside?</i> )</nobr>
        </code></td>

        <td><code>Number</code></td>

        <td>返回适应整个地图视图边界的最大缩放级别。 如果 <code>inside</code> (optional) 的设置为 <code><span class="literal">true</span></code>时，这个方法返回适应整个地图视图边界的最小缩放级别。</td>
    </tr>
    <tr>
        <td><code><b>getSize</b>()</code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td>返回现有地图容器的大小。</td>
    </tr>
    <tr>
        <td><code><b>getPixelBounds</b>()</code></td>
        <td><code>Bounds</code></td>
        <td>返回地图视图在像素投影坐标系下的边界。（很多时候对用户自定义图层和叠加很有用）</td>
    </tr>
    <tr>
        <td><code><b>getPixelOrigin</b>()</code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td>返回地图图层像素投影坐标系下的左上角的点。（很多时候对用户自定义图层和叠加很有用）</td>
    </tr>
</table>

<h3 id="map-stuff-methods">Methods for Layers and Controls（图层控制）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr id="map-addlayer">
        <td><code><b>addLayer</b>(
            <nobr>&lt;<a href="#ilayer">ILayer</a>&gt; <i>layer</i>,</nobr>
            <nobr>&lt;Boolean&gt; <i>insertAtTheBottom?</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将图层添加到地图上。如果 <code>insertAtTheBottom</code> 的选项为 <code><span class="literal">true</span></code>，图层添加时在所以图层之下。（在切换基底图时比较有用）</td>
    </tr>
    <tr>
        <td><code><b>removeLayer</b>(
            <nobr>&lt;<a href="#ilayer">ILayer</a>&gt; <i>layer</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将图层在地图上移除。</td>
    </tr>
    <tr>
        <td><code><b>hasLayer</b>(
            <nobr>&lt;<a href="#ilayer">ILayer</a>&gt; <i>layer</i> )</nobr>
        </code></td>

        <td><code>Boolean</code></td>
        <td>如果添加的图层是当前图层则返回 <code><span class="literal">true</span></code></td>
    </tr>

    <tr id="map-openpopup">
        <td><code><b>openPopup</b>(
            <nobr>&lt;<a href="#popup">Popup</a>&gt; <i>popup</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>当关闭前一个弹出框时弹出指定的对话框。（确定在同一时间只有一个打开并可用）</td>
    </tr>
    <tr id="map-closepopup">
        <td><code><b>closePopup</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>关闭 <a href="#map-openpopup">openPopup</a> 打开的弹出框。</td>
    </tr>
    <tr id="map-addcontrol">
        <td><code><b>addControl</b>(
            <nobr>&lt;<a href="#icontrol">IControl</a>&gt; <i>control</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>在地图上添加控制选项。</td>
    </tr>
    <tr>
        <td><code><b>removeControl</b>(
            <nobr>&lt;<a href="#icontrol">IControl</a>&gt; <i>control</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>在地图上移除控制选项。</td>
    </tr>
</table>


<h3 id="map-conversion-methods">Conversion Methods（转换方法）</h3>

<table>
    <tr>
        <th class="width200">方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>latLngToLayerPoint</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>返回地图图层上与地理坐标相一致的点。（在地图上进行位置叠加时比较有用）</td>
    </tr>
    <tr>
        <td><code><b>layerPointToLatLng</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>point</i> )</nobr>
        </code></td>

        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>返回给定地图上点的地理坐标系。</td>
    </tr>
    <tr>
        <td><code><b>containerPointToLayerPoint</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>point</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>将于地图容器相关的点转换为地图图层相关的点。</td>
    </tr>
    <tr>
        <td><code><b>layerPointToContainerPoint</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>point</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>将地图图层相关的点转换为地图容器相关的点。</td>
    </tr>
    <tr>
        <td><code><b>latLngToContainerPoint</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>返回与给定地理坐标系相符的地图容器的点。</td>
    </tr>
    <tr>
        <td><code><b>containerPointToLatLng</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>point</i> )</nobr>
        </code></td>

        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>返回给定地理容器点的地理坐标。</td>
    </tr>
    <tr>
        <td><code><b>project</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i>,</nobr>
            <nobr>&lt;Number&gt; <i>zoom?</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>将地理坐标投影到指定缩放级别的像素坐标系中。</td>
    </tr>
    <tr>
        <td><code><b>unproject</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>point</i>,</nobr>
            <nobr>&lt;Number&gt; <i>zoom?</i> )</nobr>
        </code></td>

        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>将像素坐标系投影到指定缩放级别的地理坐标系中。（默认为当前的缩放级别）</td>
    </tr>
    <tr>
        <td><code><b>mouseEventToContainerPoint</b>(
            <nobr>&lt;MouseEvent&gt; <i>event</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>返回鼠标点击事件对象的像素坐标（与地图左上角相关）。</td>
    </tr>
    <tr>
        <td><code><b>mouseEventToLayerPoint</b>(
            <nobr>&lt;MouseEvent&gt; <i>event</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>回鼠标点击事件对象的像素坐标（与地图图层相关）。</td>
    </tr>
    <tr>
        <td><code><b>mouseEventToLatLng</b>(
            <nobr>&lt;MouseEvent&gt; <i>event</i> )</nobr>
        </code></td>

        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>返回鼠标点击事件对象的地理坐标。</td>
    </tr>
</table>

<h3 id="map-misc-methods">Other Methods（其他方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>getContainer</b>()</code></td>
        <td><code>HTMLElement</code></td>
        <td>返回地图容器对象。</td>
    </tr>
    <tr id="map-getpanes">
        <td><code><b>getPanes</b>()</code></td>
        <td><code><a href="#map-panes">MapPanes</a></code></td>
        <td>返回不同地图对象的边框 (叠加渲染).</td>
    </tr>
    <tr id="map-whenready">
        <td><code><b>whenReady</b>(
            <nobr>&lt;Function&gt; <i>fn</i></nobr>,
            <nobr>&lt;Object&gt; <i>context?</i> )</nobr></code></td>
        <td><code>this</code></td>
        <td>当地图的位置和缩放初始化好或是时间发生之后，运行给定的回调方法，通常传递一个函数内容。</td>
    </tr>
</table>

<h3 id="map-locate-options">Locate options（位置选项）</h3>

<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>watch</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">false</span></code></td>
        <td>如果该值为 <code><span class="literal">true</span></code>则开始利用W3C的<code>watchPosition</code>方法监听位置变化情况（而不是指监听一次）。 你可以通过 <code><b>map.stopLocate</b>()</code> 方法来停止监听。</td>
    </tr>
    <tr>
        <td><code><b>setView</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">false</span></code></td>
        <td>如果该值为 <code><span class="literal">true</span></code>，则通过自动将地图视图定位到用户一定精度范围内的位置，如果地理定位失败则显示全部地图。</td>
    </tr>
    <tr>
        <td><code><b>maxZoom</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">Infinity</span></code></td>
        <td>在使用<code>setView</code>选项时视图缩放的最大级别。</td>
    </tr>
    <tr>
        <td><code><b>timeout</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">10000</span></code></td>
        <td>在触发 <code>locationerror</code> 事件之前等待地理定位的毫秒为单位的时间。</td>
    </tr>
    <tr>
        <td><code><b>maximumAge</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">0</span></code></td>
        <td>位置监听的最大生命周期。如果比最后定位回复后毫秒用时短，则 <code>locate</code> 返回一个缓存位置。</td>
    </tr>
    <tr>
        <td><code><b>enableHighAccuracy</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">false</span></code></td>
        <td>开启高精度， 参阅 <a href="http://dev.w3.org/geo/api/spec-source.html#high-accuracy">description in the W3C spec</a>。</td>
    </tr>
</table>


<h3 id="map-properties">Properties（属性）</h3>

<p>地图属性包括互动操作，允许你在运行环境中互动地控制地图行为，比如通过拖拽和点击缩放级别显示和不显示某要素。</p>

<pre><code class="javascript">map.doubleClickZoom.disable();</code></pre>

<p>你也可以通过地图属性来接受默认的地图控制项，比如属性控制。</p>

<pre><code class="javascript">map.attributionControl.addAttribution("Earthquake data &amp;copy; GeoNames");</code></pre>

<table>
    <tr>
        <th class="minwidth">Property</th>
        <th class="minwidth">类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>dragging</b></code></td>
        <td><a href="#ihandler"><code>IHandler</code></a></td>
        <td>地图拖拽处理程序，可以通过鼠标和触摸的形式。</td>
    </tr>
    <tr>
        <td><code><b>touchZoom</b></code></td>
        <td><a href="#ihandler"><code>IHandler</code></a></td>
        <td>触摸地图缩放处理程序。</td>
    </tr>
    <tr>
        <td><code><b>doubleClickZoom</b></code></td>
        <td><a href="#ihandler"><code>IHandler</code></a></td>
        <td>双击缩放处理程序。</td>
    </tr>
    <tr>
        <td><code><b>scrollWheelZoom</b></code></td>
        <td><a href="#ihandler"><code>IHandler</code></a></td>
        <td>鼠标滚动缩放处理程序。</td>
    </tr>
    <tr>
        <td><code><b>boxZoom</b></code></td>
        <td><a href="#ihandler"><code>IHandler</code></a></td>
        <td>矩形框（利用鼠标拖动）缩放处理程序。</td>
    </tr>
    <tr>
        <td><code><b>keyboard</b></code></td>
        <td><a href="#ihandler"><code>IHandler</code></a></td>
        <td>键盘导向处理程序。</td>
    </tr>
    <tr>
        <td><code><b>zoomControl</b></code></td>
        <td><a href="#control-zoom"><code>Control.Zoom</code></a></td>
        <td>缩放控制。</td>
    </tr>
    <tr>
        <td><code><b>attributionControl</b></code></td>
        <td><a href="#control-attribution"><code>Control.Attribution</code></a></td>
        <td>版权属性控制。</td>
    </tr>
</table>


<h3 id="map-panes">Map Panes（地图窗口）</h3>

<p>这是一个包括可以用来放置自定义图层的不同的地图窗口的对象。最大的区别是图层的叠置。</p>

<table>
    <tr>
        <th class="width100">属性</th>
        <th class="width100">类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>mapPane</b></code></td>
        <td><code>HTMLElement</code></td>
        <td>包含其他地图窗口的窗口。</td>
    </tr>
    <tr>
        <td><code><b>tilePane</b></code></td>
        <td><code>HTMLElement</code></td>
        <td>切片图层的窗口。</td>
    </tr>
    <tr>
        <td><code><b>objectsPane</b></code></td>
        <td><code>HTMLElement</code></td>
        <td>包含除切片窗口以外所有窗口的窗口。</td>
    </tr>
    <tr>
        <td><code><b>shadowPane</b></code></td>
        <td><code>HTMLElement</code></td>
        <td>用来隐藏图层的窗口（如标注的隐藏）。</td>
    </tr>
    <tr>
        <td><code><b>overlayPane</b></code></td>
        <td><code>HTMLElement</code></td>
        <td>这线段和多边形一类图层的窗口。</td>
    </tr>
    <tr>
        <td><code><b>markerPane</b></code></td>
        <td><code>HTMLElement</code></td>
        <td>标注图标的窗口。</td>
    </tr>
    <tr>
        <td><code><b>popupPane</b></code></td>
        <td><code>HTMLElement</code></td>
        <td>弹出的窗口。</td>
    </tr>
</table>


<h2 id="marker">L.Marker</h2>

<p>用来在地图中放置注记标志。</p>

<pre><code class="javascript">L.marker([50.5, 130.5]).addTo(map);</code></pre>

<h3>Constructor（构造函数）</h3>

<table>
    <tr>
        <th class="width200">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Marker</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i>,</nobr>
            <nobr>&lt;<a href="#marker-options">Marker options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Marker(<span class="comment">&hellip;</span>)</code><br />
            <code>L.marker(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>通过给定一个地理点和一个具有选项的对象来实例化一个注记。</td>
    </tr>
</table>

<h3 id="marker-options">Options（选项）</h3>

<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>icon</b></code></td>
        <td><code><a href="#icon">L.Icon</a></code></td>
        <td>*</td>
        <td>图标类用来表达注记。 参阅 <a href="#icon">Icon documentation</a> 以了解自定义注记图标的详细信息。 默认设置为 <code>new L.Icon.Default()</code>。</td>
    </tr>
    <tr>
        <td><code><b>clickable</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>如果是 <code><span class="literal">false</span></code>，注记则不产生鼠标事件并表现为底层地图的一部分。</td>
    </tr>
    <tr>
        <td><code><b>draggable</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">false</span></code></td>
        <td>决定注记是否可被鼠标或触摸拖动。</td>
    </tr>
    <tr>
        <td><code><b>title</b></code></td>
        <td><code>String</code></td>
        <td><code><span class="string">''</span></code></td>
        <td>注记旁边显示浏览器提示的文本信息。</td>
    </tr>
    <tr id="marker-zindexoffset">
        <td><code><b>zIndexOffset</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">0</span></code></td>
        <td>默认情况下，注记图片的叠置顺序由纬度自动设置。如果你想将某一注记放置于其他之上可用这个选项，设置一个较大的值即可，比如<code>1000</code>（或是相反地设置一个较大的负值）。</td>
    </tr>
    <tr>
        <td><code><b>opacity</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">1.0</span></code></td>
        <td>决定注记的透明度。</td>
    </tr>
    <tr>
        <td><code><b>riseOnHover</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">false</span></code></td>
        <td>如果此值为 <code><span class="literal">true</span></code>，则当把鼠标放置于注记之上时，注记会显示与其他注记之上。</td>
    </tr>
    <tr>
        <td><code><b>riseOffset</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">250</span></code></td>
        <td><code>riseOnHover</code>要素凸显时高度的补偿值。</td>
    </tr>
</table>

<h3>Events（事件）</h3>

<p>继承于 <a href="#events">these methods</a>。</p>

<table>
    <tr>
        <th class="width100">事件</th>
        <th class="width100">Data</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>click</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>当鼠标点击（或者触屏单击）注记时触发。</td>
    </tr>
    <tr>
        <td><code><b>dblclick</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>当鼠标双击（或者触屏双击）注记时触发。</td>
    </tr>
    <tr>
        <td><code><b>mousedown</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>当鼠标按下鼠标键时触发。</td>
    </tr>
    <tr>
        <td><code><b>mouseover</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>当鼠标在注记上时触发。</td>
    </tr>
    <tr>
        <td><code><b>mouseout</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>当鼠标离开注记时触发。</td>
    </tr>
    <tr>
        <td><code><b>contextmenu</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code>
        <td>当鼠标右击注记时触发。</td>
    </tr>
    <tr>
        <td><code><b>dragstart</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>当用户拖动注记时触发。</td>
    </tr>
    <tr>
        <td><code><b>drag</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>当用户拖动注记时不断触发。</td>
    </tr>
    <tr>
        <td><code><b>dragend</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>当用户停止拖动注记时触发。</td>
    </tr>
    <tr>
        <td><code><b>move</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>当注记通过定义经纬度而移动时触发。新的坐标包含事件参数。</td>
    </tr>
    <tr>
        <td><code><b>remove</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>当注记在地图上被删除时触发。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>addTo</b>(
            <nobr>&lt;<a href="#map">Map</a>&gt; <i>map</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>在地图上添加注记。</td>
    </tr>
    <tr>
        <td><code><b>getLatLng</b>()</code></td>
        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>返回当前注记的地理位置。</td>
    </tr>
    <tr>
        <td><code><b>setLatLng</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将注记位置更改到给定点。</td>
    </tr>
    <tr>
        <td><code><b>setIcon</b>(
            <nobr>&lt;<a href="#icon">Icon</a>&gt; <i>icon</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>更改注记的图标。</td>
    </tr>
    <tr>
        <td><code><b>setZIndexOffset</b>(
            <nobr>&lt;Number&gt; <i>offset</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>更改注记的 <a href="#marker-zindexoffset">zIndex offset</a> 。</td>
    </tr>
    <tr>
        <td><code><b>setOpacity</b>(
            <nobr>&lt;Number&gt; <i>opacity</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>更改注记的透明度。</td>
    </tr>
    <tr>
        <td><code><b>update</b>()</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>更新注记的位置，在直接更改经纬度对象的坐标时比较有用。</td>
    </tr>
    <tr id="marker-bindpopup">
        <td><code><b>bindPopup</b>(
            <nobr>&lt;String&gt; <i>htmlContent</i>,</nobr>
            <nobr>&lt;<a href="#popup-options">Popup options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>当点击一个注记时绑定一个特定的HTML内容的弹出窗口。你也可以用Marker中的 <a href="#marker-openpopup">openPopup</a> 方法打开绑定的弹出窗口。</td>
    </tr>
    <tr id="marker-unbindpopup">
        <td><code><b>unbindPopup</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>将先前用 <code>bindPopup</code>方法绑定的注记取消。</td>
    </tr>
    <tr id="marker-openpopup">
        <td><code><b>openPopup</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>打开先前用 <a href="#marker-bindpopup">bindPopup</a> 方法绑定的弹出框。</td>
    </tr>
    <tr id="marker-closepopup">
        <td><code><b>closePopup</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>关闭已打开的注记的弹出框。</td>
    </tr>
</table>

<h3 id="marker-interaction-handlers">（交互操作处理程序）</h3>

<p>启用或禁用某些功能,如拖动。示例:</p>

<pre><code class="javascript">marker.dragging.disable();</code></pre>

<table>
    <tr>
        <th class="width100">属性</th>
        <th class="width100">类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td>dragging</td>
        <td><a href="#ihandler"><code>IHandler</code></a></td>
        <td>注记拖动处理程序（包括鼠标和触摸）。</td>
    </tr>
</table>



<h2 id="popup">L.Popup</h2>

<p>Used to open popups in certain places of the map. Use <a href="#map-openpopup">Map#openPopup</a> to open popups while making sure that only one popup is open at one time (recommended for usability), or use <a href="#map-addlayer">Map#addLayer</a> to open as many as you want.</p>

<h3>示例</h3>
<p>简单的在一个注记绑定一个弹出框：</p>
<pre><code class="javascript">marker.bindPopup(popupContent).openPopup();</code></pre>
<p>绘图线条同样拥有 <code>bindPopup</code> 方法。可以通过很多方式在地图上添加弹出框:</p>

<pre><code class="javascript">var popup = L.popup()
    .setLatLng(latlng)
    .setContent('&lt;p&gt;Hello world!&lt;br /&gt;这是一个弹出框.&lt;/p&gt;')
    .openOn(map);</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th>构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Popup</b>(
            <nobr>&lt;<a href="#popup-options">Popup options</a>&gt; <i>options?</i>,</nobr>
            <nobr>&lt;object&gt; <i>source?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Popup(<span class="comment">&hellip;</span>)</code><br />
            <code>L.popup(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>通过给定一些选项构造一个弹出框对象，对象用来描述出现形式和位置还有一个可选对象来根据指向的资源对象标注弹出框。</td>
    </tr>
</table>

<h3 id="popup-options">Options(选项)</h3>

<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>maxWidth</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">300</span></code></td>
        <td>弹出框的最大宽度。</td>
    </tr>
    <tr>
        <td><code><b>minWidth</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">50</span></code></td>
        <td>弹出框的最小宽度。</td>
    </tr>
    <tr>
        <td><code><b>maxHeight</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="literal">null</span></code></td>
        <td>设置后，如果内容超过弹出窗口的给定高度则产生一个可以滚动的容器。</td>
    </tr>
    <tr>
        <td><code><b>autoPan</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>如果你不想地图自动平移来适应打开的弹出框，就设置其为 <code><span class="literal">false</span></code> 。</td>
    </tr>
    <tr>
        <td><code><b>closeButton</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>控制弹出窗口中出现的关闭按钮。</td>
    </tr>
    <tr>
        <td><code><b>offset</b></code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td><code><nobr>Point(<span class="number">0</span>, <span class="number">6</span>)</nobr>
        </code></td>
        <td>弹出窗口位置的补偿值。在同一图层中打开弹出窗口时对于控制锚点比较有用。</td>
    </tr>
    <tr>
        <td><code><b>autoPanPadding</b></code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td><code><nobr>Point(<span class="number">5</span>, <span class="number">5</span>)</nobr>
        </code></td>
        <td>在地图视图自动平移产生后弹出窗口和地图视图之间的边缘。</td>
    </tr>
    <tr>
        <td><code><b>zoomAnimation</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>决定是否在所在级别上弹出窗口。如果你在弹出窗口中有flash内容的最好将其设置为不可用。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th class="width250">方法</th>
        <th class="minwidth">返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>addTo</b>(
            <nobr>&lt;<a href="#map">Map</a>&gt; <i>map</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将弹出窗口添加到地图上。</td>
    </tr>
    <tr>
        <td><code><b>openOn</b>(
            <nobr>&lt;<a href="#map">Map</a>&gt; <i>map</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将弹出窗口添加到地图上并将之前的一个关闭。与 <code>map.openPopup(popup)</code>方法相同。</td>
    </tr>
    <tr>
        <td><code><b>setLatLng</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>设置弹出窗口打开的地理上的点位。</td>
    </tr>
    <tr>
        <td><code><b>setContent</b>(
            <nobr>&lt;String|HTMLElement&gt; <i>htmlContent</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>设置弹出窗口的HTML内容。</td>
    </tr>
</table>



<h2 id="tilelayer">L.TileLayer</h2>

<p>用来在地图上载入和显示切片图层，用 <a href="#ilayer">ILayer</a> 接口实现。</p>

<h3>示例</h3>

<pre><code class="javascript">L.tileLayer('http://{s}.tile.somedomain.com/{key}/{styleId}/256/{z}/{x}/{y}.png', {
    key: 'API-key',
    styleId: 997
    }).addTo(map);</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width250">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.TileLayer</b>(
            <nobr>&lt;String&gt; <i><a href="#url-template">urlTemplate</a></i>,</nobr>
            <nobr>&lt;<a href="#tilelayer-options">TileLayer options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.TileLayer(<span class="comment">&hellip;</span>)</code><br />
            <code>L.tileLayer(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>过给定 <a href="#url-template">URL template</a> 和具有选项的对象来实例化一个切片图层。</td>
    </tr>
</table>

<h3 id="url-template">URL template</h3>

<p>见下面的例子:</p>

<pre><code class="javascript">'http://{s}.somedomain.com/blabla/{z}/{x}/{y}.png'</code></pre>

<p><code>{s}</code> 意味着一个可用的子域(使用顺序和并行请求帮助浏览器每域限制;子域值中指定选项;a、b或c在默认情况下,可以省略),<code>{z}</code> &mdash; 缩放级别, <code>{x}</code> 和 <code>{y}</code> &mdash; 切片坐标。</p>

<p>示例:</p>

<pre><code class="javascript">L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});</code></pre>

<h3 id="tilelayer-options">Options（选项）</h3>

<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>minZoom</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">0</span></code></td>
        <td>最小级别数</td>
    </tr>
    <tr>
        <td><code><b>maxZoom</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">18</span></code></td>
        <td>最大级别数</td>
    </tr>
    <tr>
        <td><code><b>tileSize</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">256</span></code></td>
        <td>切片尺寸（宽度和高度的像素值，假设切片是正方形的）</td>
    </tr>
    <tr>
        <td><code><b>subdomains</b></code></td>
        <td><code>String</code> or <code>String[]</code></td>
        <td><code><span class="string">'abc'</span></code></td>
        <td>服务的子域。可以传递一个字符串（其中每一个字母都是一个子域名称）或是一个字符串数组。</td>
    </tr>
    <tr>
        <td><code><b>errorTileUrl</b></code></td>
        <td><code>String</code></td>
        <td><code><span class="string">''</span></code></td>
        <td>图片的URL给出加载错误的位置。</td>
    </tr>
    <tr>
        <td><code><b>attribution</b></code></td>
        <td><code>String</code></td>
        <td><code><span class="string">''</span></code></td>
        <td>e.g. "&copy; somedomain" &mdash; 描述了图层数据的版权属性。</td>
    </tr>
    <tr>
        <td><code><b>tms</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">false</span></code></td>
        <td>如果此值为 <code><span class="literal">true</span></code>, 反转切片Y轴的编号（对于TMS服务需将此项打开）。</td>
    </tr>
    <tr>
        <td><code><b>continuousWorld</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">false</span></code></td>
        <td>如果设置为 <code><span class="literal">true</span></code>, 切片的坐标系不会被世界范围的宽度（-180度到180度）所覆盖，也不会被在世界范围的高度（-90度到90度）之内。你可以将此用在不反应真是世界的地图上（比如游戏、室内或照片的地图）。</td>
    </tr>
    <tr>
        <td><code><b>noWrap</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">false</span></code></td>
        <td>如果设置此项为 <code><span class="literal">true</span></code>，则切片不会用重复填充来表示世界范围（经度-180到180之间）之外的地方。</td>
    </tr>
    <tr>
        <td><code><b>zoomOffset</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">0</span></code></td>
        <td>用此值来补偿URL中地图的缩放级别。</td>
    </tr>
    <tr>
        <td><code><b>zoomReverse</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">false</span></code></td>
        <td>如果此项为 <code><span class="literal">true</span></code>，URL中的缩放级别会被反转（用最大到最小缩放级别来替代缩放级别）。</td>
    </tr>
    <tr>
        <td><code><b>opacity</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">1.0</span></code></td>
        <td>切片图层的透明度。</td>
    </tr>
    <tr>
        <td><code><b>zIndex</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="literal">null</span></code></td>
        <td>切片图层明确的叠置顺序，默认此项不会被设置。</td>
    </tr>
    <tr>
        <td><code><b>unloadInvisibleTiles</b></code></td>
        <td><code>Boolean</code></td>
        <td>depends</td>
        <td>如果此项为 <code><span class="literal">true</span></code>在平移后所有看不到的切片都会被移除（用以更好地显示），在移动设备的webkit中默认是<code><span class="literal">true</span></code>， 其他的默认为 <code><span class="literal">false</span></code>。</td>
    </tr>
    <tr>
        <td><code><b>updateWhenIdle</b></code></td>
        <td><code>Boolean</code></td>
        <td>depends</td>
        <td>如果此项为 <code><span class="literal">false</span></code>，在平移过程中新的切片将会载入，其他的在其后载入（用以更好地显示），在移动设备webKit中默认是<code><span class="literal">true</span></code>，其他默认<code><span class="literal">false</span></code>。</td>
    </tr>
    <tr>
        <td><code><b>detectRetina</b></code></td>
        <td><code><code>Boolean</code></code></td>
        <td><code><span class="literal">false</span></code></td>
        <td>如果此项为 <code><span class="literal">true</span></code>，并且用户是视网膜显示模式，会请求规定大小一般的四个切片和一个地区内一个更大的缩放级别来利用高分辨率。</td>
    </tr>
    <tr>
        <td><code><b>reuseTiles</b></code></td>
        <td><code><code>Boolean</code></code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>如果此项为 <code><span class="literal">true</span></code>，在平移后不可见的切片被放入一个队列中，在新的切片开始可见时他们会被取回（而不是动态地创建一个新的）。这理论上可以降低内存使用率并可以去除在需要新的切片时预留内存。</td>
    </tr>
</table>

<h3>Events（事件）</h3>

<p>继承于 <a href="#events">these methods</a>.</p>

<table>
    <tr>
        <th class="width100">事件</th>
        <th class="width100">Data</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>loading</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>当切片图层加载完可见切片后触发。</td>
    </tr>
    <tr>
        <td><code><b>load</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>在加载切片时触发。</td>
    </tr>
    <tr>
        <td><code><b>tileload</b></code></td>
        <td><code><a href="#tile-event">TileEvent</a></code></td>
        <td>Fired when a tile loads.</td>
    </tr>
    <tr>
        <td><code><b>tileunload</b></code></td>
        <td><code><a href="#tile-event">TileEvent</a></code></td>
        <td>在切片被移除时触发 (e.g. 打开了 <code>unloadInvisibleTiles</code> ).</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>addTo</b>(
            <nobr>&lt;<a href="#map">Map</a>&gt; <i>map</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将图层加到地图上。</td>
    </tr>
    <tr>
        <td><code><b>bringToFront</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>将此切片图层放到所有切片图层之上。</td>
    </tr>
    <tr>
        <td><code><b>bringToBack</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>将此切片图层放到所有切片图层之下。</td>
    </tr>
    <tr>
        <td><code><b>setOpacity</b>(
            <nobr>&lt;Number&gt; <i>opacity</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>改变切片图层的透明度。</td>
    </tr>
    <tr>
        <td><code><b>setZIndex</b>(
            <nobr>&lt;Number&gt; <i>zIndex</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>设置切片图层的叠放顺序。</td>
    </tr>
    <tr>
        <td><code><b>redraw</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>清除所有的切片并重新向服务端申请他们。</td>
    </tr>
    <tr>
        <td><code><b>setUrl</b>(
            <nobr>&lt;String&gt; <i><a href="#url-template">urlTemplate</a></i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>更新图层的URL模板并重绘他们。</td>
    </tr>
</table>



<h2 id="tilelayer-wms">L.TileLayer.WMS</h2>

<p>用来显示地图上切片图层的WMS服务，继承自 <a href="#tilelayer">TileLayer</a>.</p>

<h3>示例</h3>

<pre><code class="javascript">var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
    layers: 'nexrad-n0r-900913',
    format: 'image/png',
    transparent: true,
    attribution: "Weather data &copy; 2012 IEM Nexrad"
    });</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width250">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.TileLayer.WMS</b>(
            <nobr>&lt;String&gt; <i>baseUrl</i></nobr>,
            <nobr>&lt;<a href="#tilelayer-wms-options">TileLayer.WMS options</a>&gt; <i>options</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.TileLayer.WMS(<span class="comment">&hellip;</span>)</code><br />
            <code>L.tileLayer.wms(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>通过给定一个基本的WMS服务的URL和WMS参数或选项对象来实例化一个WMS切片图层对象。</td>
    </tr>
</table>

<h3 id="tilelayer-wms-options">Options（选项）</h3>

<p>Includes all <a href="#tilelayer-options">TileLayer options</a> and additionally:</p>

<table>
    <tr>
        <th class="width100">参数</th>
        <th class="width100">类型</th>
        <th class="width100">默认</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>layers</b></code></td>
        <td><code>String</code></td>
        <td><code><span class="string">''</span></code></td>
        <td><b>(required)</b> 以逗号分隔符隔开的WMS图层列表。</td>
    </tr>
    <tr>
        <td><code><b>styles</b></code></td>
        <td><code>String</code></td>
        <td><code><span class="string">''</span></code></td>
        <td>以逗号分隔符隔开的WMS样式列表。</td>
    </tr>
    <tr>
        <td><code><b>format</b></code></td>
        <td><code>String</code></td>
        <td><code><span class="string">'image/jpeg'</span></code></td>
        <td>以 (use <code><span class="string">'image/png'</span></code>显示透明图层的 WMS图像格式).</td>
    </tr>
    <tr>
        <td><code><b>transparent</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">false</span></code></td>
        <td>如果该项为 <code><span class="literal">true</span></code>， WMS服务返回透明图片。</td>
    </tr>
    <tr>
        <td><code><b>version</b></code></td>
        <td><code>String</code></td>
        <td><code><span class="string">'1.1.1'</span></code></td>
        <td>WMS服务的版本。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>setParams</b>(
            <nobr>&lt;<a href="#tilelayer-wms-options">WMS parameters</a>&gt; <i>params</i></nobr>,
            <nobr>&lt;Boolean&gt; <i>noRedraw?</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>融合新的参数和在当前屏幕中重申请的切片 (除非 <code>noRedraw</code> 设置为 <code><span class="literal">true</span></code>).</td>
    </tr>
</table>


<h2 id="tilelayer-canvas">L.TileLayer.Canvas</h2>

<p>用Canvas来创建浏览器端绘制的切片图层的底层画布。 继承于 <a href="#tilelayer">TileLayer</a>.</p>

<h3>示例</h3>

<pre><code class="javascript">var canvasTiles = L.tileLayer.canvas();

    canvasTiles.drawTile = function(canvas, tilePoint, zoom) {
    var ctx = canvas.getContext('2d');
    // draw something on the tile canvas
    }</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width200">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.TileLayer.Canvas</b>(
            <nobr>&lt;<a href="#tilelayer-options">TileLayer options</a>&gt; <i>options?</i> )</nobr>
        </code></td>
        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.TileLayer.Canvas(<span class="comment">&hellip;</span>)</code><br />
            <code>L.tileLayer.canvas(<span class="comment">&hellip;</span>)</code>
        </td>
        <td>通过一个具有选项的对象来实例化一个切片图层画布对象。</td>
    </tr>
</table>

<h3>Options（选项）</h3>
<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>async</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">false</span></code></td>
        <td>在实例化时可以异步地绘制切片。在全部绘制完后， <a href="#tilelayer-canvas-tiledrawn">tileDrawn</a> 方法需要在每个切片上使用。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th class="width200">方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr id = "tilelayer-canvas-drawtile">
        <td><code><b>drawTile</b>(
            <nobr>&lt;HTMLCanvasElement&gt; <i>canvas</i></nobr>,
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>tilePoint</i></nobr>,
            <nobr>&lt;Number&gt; <i>zoom</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>在创建实例来绘制切片后你需要定义此方法； <code>canvas</code> 你可以绘制的实际上的切片画布， <code>tilePoint</code>反应了切片的数目， <code>zoom</code>是当前的缩放级别。</td>
    </tr>
    <tr id="tilelayer-canvas-tiledrawn">
        <td><code><b>tileDrawn</b>( <nobr>&lt;HTMLCanvasElement&gt; <i>canvas</i></nobr> )</code></td>
        <td>-</td>
        <td>如果 <code>async</code> 选项被定义，在全部绘制完后，这个函数需要在每个切片上使用。 <code>canvas</code>与画布对象相同，传递参数给 <a href="#tilelayer-canvas-drawtile">drawTile</a>。</td>
    </tr>
</table>


<h2 id="imageoverlay">L.ImageOverlay</h2>

<p>用来在地图上规定范围内载入和显示单幅图像，继承自 <a href="#ilayer">ILayer</a> 接口。</p>

<h3>示例</h3>

<pre><code class="javascript">var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
    imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];

    L.imageOverlay(imageUrl, imageBounds).addTo(map);</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width250">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.ImageOverlay</b>(
            <nobr>&lt;String&gt; <i>imageUrl</i></nobr>,
            <nobr>&lt;<a href="#latlngbounds">LatLngBounds</a>&gt; <i>bounds</i></nobr>,
            <nobr>&lt;<a href="#imageoverlay-options">ImageOverlay options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.ImageOverlay(<span class="comment">&hellip;</span>)</code><br />
            <code>L.imageOverlay(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>通过给定图像的URL和相关的地理范围来实例化一个图像叠加层对象。</td>
    </tr>
</table>

<h3 id="imageoverlay-options">Options（选项）</h3>
<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th class="minwidth">默认</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>opacity</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">1.0</span></code></td>
        <td>图像叠加层的透明度。</td>
    </tr>
</table>

<h3 id="imageoverlay-methods">Methods（方法）</h3>
<table>
    <tr>
        <th class="width250">方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>addTo</b>(
            <nobr>&lt;<a href="#map">Map</a>&gt; <i>map</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将图像叠加层添加到地图上。</td>
    </tr>
    <tr>
        <td><code><b>setOpacity</b>(
            <nobr>&lt;Number&gt; <i>opacity</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>设置叠加层的透明度。</td>
    </tr>
    <tr>
        <td><code><b>bringToFront</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>将叠加层置于所有层的顶层。</td>
    </tr>
    <tr>
        <td><code><b>bringToBack</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>将叠加层置于所有层的底层。</td>
    </tr>
</table>


<h2 id="path">L.Path</h2>
<p>是包含选项和与适量叠加层共享常量的抽象类。不可以接使用。</p>

<h3 id="path-options">Options（选项）</h3>
<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th class="minwidth">默认</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>stroke</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>路径是否描边。设置为<code><span class="literal">false</span></code>时，多边形和圆的边界将不可见。</td>
    </tr>
    <tr>
        <td><code><b>color</b></code></td>
        <td><code>String</code></td>
        <td><code><span class="string">'#03f'</span></code></td>
        <td>描边颜色。</td>
    </tr>
    <tr>
        <td><code><b>weight</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">5</span></code></td>
        <td>描边的像素级别的宽度。</td>
    </tr>
    <tr>
        <td><code><b>opacity</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">0.5</span></code></td>
        <td>描边透明度。</td>
    </tr>
    <tr>
        <td><code><b>fill</b></code></td>
        <td><code>Boolean</code></td>
        <td>depends</td>
        <td>路径是否填充颜色。设置为 <code><span class="literal">false</span></code> 时，多边形和圆的填充内容不可见。</td>
    </tr>
    <tr>
        <td><code><b>fillColor</b></code></td>
        <td><code>String</code></td>
        <td>same as color</td>
        <td>填充颜色。</td>
    </tr>
    <tr>
        <td><code><b>fillOpacity</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">0.2</span></code></td>
        <td>填充透明度。</td>
    </tr>
    <tr>
        <td><code><b>dashArray</b></code></td>
        <td><code>String</code></td>
        <td><code><span class="literal">null</span></code></td>
        <td>定义描边线型的字符串。这在画布上不起作用。（比如android 2）</td>
    </tr>
    <tr>
        <td><code><b>clickable</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>如果此项为 <code><span class="literal">false</span></code>，则矢量不产生鼠标事件并表现为底图的一部分。</td>
    </tr>
</table>

<h3>Events（事件）</h3>

<p>继承于 <a href="#events">events</a>.</p>

<table>
    <tr>
        <th class="width100">事件</th>
        <th class="width100">Data</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>click</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>用户点击或点触对象时触发。</td>
    </tr>
    <tr>
        <td><code><b>dblclick</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>用户双击或连续两次点触对象时触发。</td>
    </tr>
    <tr>
        <td><code><b>mousedown</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>当用户在对象上按下鼠标时触发。</td>
    </tr>
    <tr>
        <td><code><b>mouseover</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>当鼠标置于对象上方时触发。</td>
    </tr>
    <tr>
        <td><code><b>mouseout</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>当鼠标离开对象时触发。</td>
    </tr>
    <tr>
        <td><code><b>contextmenu</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>当用户在对象上点击鼠标右键时触发，当此事件被监听时，会阻止弹出浏览器本身的右键菜单。</td>
    </tr>
    <tr>
        <td><code><b>add</b></code></td>
        <td><code><a href="#event">Event</a></code>
        <td>当路径被添加在地图上时触发。</td>
    </tr>
    <tr>
        <td><code><b>remove</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>当路径在地图上移除时触发。</td>
    </tr>
</table>

<h3 id="path-methods">Methods（方法）</h3>
<table>
    <tr>
        <th class="width250">方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>addTo</b>(
            <nobr>&lt;<a href="#map">Map</a>&gt; <i>map</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将图层添加到地图上。</td>
    </tr>
    <tr id="path-bindpopup">
        <td><code><b>bindPopup</b>(
            <nobr>&lt;String&gt; <i>htmlContent</i></nobr>,
            <nobr>&lt;<a href="#popup-options">Popup options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将具有特定HTML内容的弹出框与点击路径绑定起来。</td>
    </tr>
    <tr id="path-unbindpopup">
        <td><code><b>unbindPopup</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>将之前的弹出框绑定解除。</td>
    </tr>
    <tr id="path-openpopup">
        <td><code><b>openPopup</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng?</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>打开之前通过 <a href="#path-bindpopup">bindPopup</a> 方法与路径上指定点或未指定情况下某一点绑定的弹出框。</td>
    </tr>
    <tr id="path-closepopup">
        <td><code><b>closePopup</b>()</code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>如果与路径绑定的弹出框是打开状态的，则将其关闭。</td>
    </tr>
    <tr id="path-setstyle">
        <td><code><b>setStyle</b>(
            <nobr>&lt;<a href="#path-options">Path options</a>&gt; <i>object</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>更改给予对象选项对象的路径的表现形式。</td>
    </tr>
    <tr id="path-getbounds">
        <td><code><b>getBounds</b>()</code></td>
        <td><code><a href="#latlngbounds">LatLngBounds</a></code></td>
        <td>返回路径的经纬度绑定信息。</td>
    </tr>
    <tr>
        <td><code><b>bringToFront</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>将此层移至所以路径层的最上层。</td>
    </tr>
    <tr>
        <td><code><b>bringToBack</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>将此层移至所以路径层的最底层。</td>
    </tr>
    <tr>
        <td><code><b>redraw</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>重绘图层。在更改了路径的坐标时比较有用。</td>
    </tr>
</table>

<h3>Static properties（静态属性）</h3>
<table>
    <tr>
        <th>常量</th>
        <th>类型</th>
        <th>值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code>SVG</code></td>
        <td><code>Boolean</code></td>
        <td>depends</td>
        <td>如果用SVG来表达矢量，则此值为true（在当前大多数浏览器中是true）。</td>
    </tr>
    <tr>
        <td><code>VML</code></td>
        <td><code>Boolean</code></td>
        <td>depends</td>
        <td>如果VML用来表达矢量，则此值为true（在IE 6-8中适用）。</td>
    </tr>
    <tr>
        <td><code>CANVAS</code></td>
        <td><code>Boolean</code></td>
        <td>depends</td>
        <td>如果canvas用来表达矢量，则此值为true（在android 2中适用）。你也可以在页面中载入Leaflet之前通过设置全局变量 <code>L_PREFER_CANVAS</code> 为 <code><span class="literal">true</span></code> 来强制使用此项——有时在表达上千上万相同的注记时会显著地提高性能，但目前由于漏洞导致移除图层非常慢。</td>
    </tr>
    <tr>
        <td><code>CLIP_PADDING</code></td>
        <td><code>Number</code></td>
        <td><nobr><code><span class="number">0.5</span></code> for SVG</nobr><br /><nobr><code><span class="number">0.02</span></code> for VML</nobr></td>
        <td>决定地图视图周围裁剪区域延展的大小（与大小相关，比如0.5在每个方向上是屏幕的一半）。较小的值意味着在拖动地图时你会看到被裁剪路径的末端，较大值会降低绘制性能。</td>
    </tr>
</table>


<h2 id="polyline">L.Polyline</h2>

<p>绘制叠加在地图上线段的类。继承自 <a href="#path">Path</a>. 用 <a href="#map-addlayer">Map#addLayer</a> 来添加到地图上。</p>

<h3>示例</h3>
<pre><code class="javascript">// 使用多个点数据来构建一条红色的线条
    var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);

    // zoom the map to the polyline
    map.fitBounds(polyline.getBounds());</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width250">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Polyline</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>[]&gt; <i>latlngs</i></nobr>,
            <nobr>&lt;<a href="#polyline-options">Polyline options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Polyline(<span class="comment">&hellip;</span>)</code><br />
            <code>L.polyline(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>通过给定的地理点组成的数组和任意的选项对象实例化一个线段。</td>
    </tr>
</table>

<h3 id="polyline-options">Options（选项）</h3>

<p>继承于 <a href="#path-options">Path options</a> </p>

<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>smoothFactor</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">1.0</span></code></td>
        <td>决定每一个缩放级别上线段简化程度。如果大的话意味着更好的表现和看起来更光滑，小的话意味更准确地表示。</td>
    </tr>
    <tr>
        <td><code><b>noClip</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">false</span></code></td>
        <td>不允许线段裁剪。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<p>继承于 <a href="#path-methods">Path methods</a> </p>

<table>
    <tr>
        <th class="width250">方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>addLatLng</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>向线段添加一个点。</td>
    </tr>
    <tr>
        <td><code><b>setLatLngs</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>[]&gt; <i>latlngs</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>用所给的地理点的数组替代线段上的点。</td>
    </tr>
    <tr>
        <td><code><b>getLatLngs</b>()</code></td>
        <td><code><a href="#latlng">LatLng</a>[]</code></td>
        <td>返回路径上的点组成的数组。</td>
    </tr>
    <tr>
        <td><code><b>spliceLatLngs</b>(
            <nobr>&lt;Number&gt; <i>index</i></nobr>,
            <nobr>&lt;Number&gt; <i>pointsToRemove</i></nobr>,
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng?</i>, &hellip; )</nobr>
        </code></td>

        <td><code><a href="#latlng">LatLng</a>[]</code></td>
        <td>允许添加、移除和更改线段上的点。同Array#splice的语法一致。返回移除点组成的数组。</td>
    </tr>
    <tr>
        <td><code><b>getBounds</b>()</code></td>
        <td><code><a href="#latlngbounds">LatLngBounds</a></code></td>
        <td>返回线段的经纬度边界。</td>
    </tr>
</table>



<h2 id="multipolyline">L.MultiPolyline</h2>

<p>是 <a href="#featuregroup">FeatureGroup</a> 的扩展，用来创建多线（在同一图层中由多个共享样式和弹出框的线段组成）。</p>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th>构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.MultiPolyline</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>[][]&gt; <i>latlngs</i></nobr>,
            <nobr>&lt;<a href="#polyline-options">Polyline options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.MultiPolyline(<span class="comment">&hellip;</span>)</code><br />
            <code>L.multiPolyline(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>通过给定的地理点的二维数组（其中每个一维数组表示一个线段）和选项对象来实例化一个多线对象。</td>
    </tr>
</table>



<h2 id="polygon">L.Polygon</h2>

<p>在地图上绘制多边形的类。是 <a href="#polyline">Polyline</a>的扩展。用 <a href="#map-addlayer">Map#addLayer</a>添加到地图上。</p>

<p>创建多边形时经过的点没有传统意义上的起点和终点——最好将这种点指出来。</p>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th>构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Polygon</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>[]&gt; <i>latlngs</i></nobr>,
            <nobr>&lt;<a href="#polyline-options">Polyline options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Polygon(<span class="comment">&hellip;</span>)</code><br />
            <code>L.polygon(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>通过给定地理点组成的数组和选项对象来实例化一个多边形（同线段构造方法相同）。你也可以通过传递经纬度的二维数组来创建一个带有洞的多边形，第一个经纬度数组表示外环，剩下的表示里面的洞。</td>
    </tr>
</table>

<p>Polygon 的 options 和 methods 同 Polyline.</p>



<h2 id="multipolygon">L.MultiPolygon</h2>

<p>是 <a href="#featuregroup">FeatureGroup</a> 的扩展，用来创建多多边形（在同一图层上由共享样式和弹出框的多个多边形组成）。</p>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th>构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.MultiPolygon</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>[][]&gt; <i>latlngs</i></nobr>,
            <nobr>&lt;<a href="#polyline-options">Polyline options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.MultiPolygon(<span class="comment">&hellip;</span>)</code><br />
            <code>L.multiPolygon(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>通过给定的经纬度的二维数组（每个一维数组表示一个多边形）和选项对象实例化多多边形（同多线相同）。</td>
    </tr>
</table>

<h2 id="rectangle">L.Rectangle</h2>

<p>在地图上绘制矩形的类。是 <a href="#polygon">Polygon</a>的扩展。用 <a href="#map-addlayer">Map#addLayer</a> 添加到地图上。</p>

<h3>示例</h3>
<pre><code class="javascript">// define rectangle geographical bounds
    var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];

    // create an orange rectangle
    L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);

    // zoom the map to the rectangle bounds
    map.fitBounds(bounds);</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width250">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Rectangle</b>(
            <nobr>&lt;<a href="#latlngbounds">LatLngBounds</a>&gt; <i>bounds</i></nobr>,
            <nobr>&lt;<a href="#path-options">Path options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Rectangle(<span class="comment">&hellip;</span>)</code><br />
            <code>L.rectangle(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>通过给定的地理边界和选项对象来实例化一个矩形对象。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<p>可以使用 <a href="#path-methods">Path-Methods</a> 的方法 和 以下的方法:</p>

<table>
    <tr>
        <th class="width250">方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>setBounds</b>(
            <nobr>&lt;<a href="#latlngbounds">LatLngBounds</a>&gt; <i>bounds</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>根据传递的边界重绘矩形。</td>
    </tr>
</table>


<h2 id="circle">L.Circle</h2>

<p>在地图上绘制圆形叠加物的类。是 <a href="#path">Path</a>的延伸。用<a href="#map-addlayer">Map#addLayer</a>来添加到地图上。</p>

<pre><code class="javascript">L.circle([20.5, 110.5], 200).addTo(map);</code></pre></code>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th>构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Circle</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i></nobr>,
            <nobr>&lt;Number&gt; <i>radius</i></nobr>,
            <nobr>&lt;<a href="#path-options">Path options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Circle(<span class="comment">&hellip;</span>)</code><br />
            <code>L.circle(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>通过给定的地理点和以米为单位的半径和选项对象来实例化一个圆对象。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th class="width200">方法</th>
        <th class="minwidth">返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>getLatLng</b>()</code></td>
        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>返回圆当前的地理位置。</td>
    </tr>
    <tr>
        <td><code><b>getRadius</b>()</code></td>
        <td><code>Number</code></td>
        <td>返回圆的半径，以米为单位。</td>
    </tr>
    <tr>
        <td><code><b>setLatLng</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将圆放置到一个新的位置。</td>
    </tr>
    <tr>
        <td><code><b>setRadius</b>(
            <nobr>&lt;Number&gt; <i>radius</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>设置圆的半径，以米为单位。</td>
    </tr>
</table>



<h2 id="circlemarker">L.CircleMarker</h2>

<p>是一个特定半径的圆，半径单位是像素。是 <a href="#circle">Circle</a>的延伸。通过 <a href="#map-addlayer">Map#addLayer</a>添加到地图上。</p>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width200">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.CircleMarker</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i></nobr>,
            <nobr>&lt;<a href="#path-options">Path options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.CircleMarker(<span class="comment">&hellip;</span>)</code><br />
            <code>L.circleMarker(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>通过给定的地理点和选项对象来实例化一个圆注记。默认的半径是10像素，并且可以通过在路径选项中传递一个半径参数来修改半径。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th class="width200">方法</th>
        <th class="minwidth">返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>setLatLng</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将圆注记放置于一个新的位置。</td>
    </tr>
    <tr>
        <td><code><b>setRadius</b>(
            <nobr>&lt;Number&gt; <i>radius</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>设置圆注记的半径，以像素为单位。</td>
    </tr>
</table>



<h2 id="layergroup">L.LayerGroup</h2>

<p>用来将几个图层组成一个组并作为一个图层来处理。如果你将其添加到地图上，组中任何图层的添加或移除都将使其同样在地图添加或删除。继承自 <a href="#ilayer">ILayer</a> 接口。</p>

<pre><code class="javascript">L.layerGroup([marker1, marker2])
    .addLayer(polyline)
    .addTo(map);</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width250">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.LayerGroup</b>(
            <nobr>&lt;<a href="#ilayer">ILayer</a>[]&gt; <i>layers?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.LayerGroup(<span class="comment">&hellip;</span>)</code><br />
            <code>L.layerGroup(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>创建一个组，视情况指定一组初始的图层。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th class="width200">方法</th>
        <th class="minwidth">返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>addTo</b>(
            <nobr>&lt;<a href="#map">Map</a>&gt; <i>map</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将图组添加到地图上。</td>
    </tr>
    <tr>
        <td><code><b>addLayer</b>(
            <nobr>&lt;<a href="#ilayer">ILayer</a>&gt; <i>layer</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将给定的图层添加到组中。</td>
    </tr>
    <tr>
        <td><code><b>removeLayer</b>(
            <nobr>&lt;<a href="#ilayer">ILayer</a>&gt; <i>layer</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将给定的图层从组中移除。</td>
    </tr>
    <tr>
        <td><code><b>hasLayer</b>(
            <nobr>&lt;<a href="#ilayer">ILayer</a>&gt; <i>layer</i> )</nobr>
        </code></td>

        <td><code>Boolean</code></td>
        <td>如果当前添加的图层是给定的图层，返回 <code><span class="literal">true</span></code></td>
    </tr>
    <tr>
        <td><code><b>clearLayers</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>将组中的图层清空。</td>
    </tr>
    <tr>
        <td><code><b>eachLayer</b>(
            <nobr>&lt;Function&gt; <i>fn</i></nobr>,
            <nobr>&lt;Object&gt; <i>context?</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>遍历组中的图层，需选择一个符合情况的迭代函数。
<pre><code>group.eachLayer(function (layer) {
    layer.bindPopup('Hello');
    });</code></pre>
        </td>
    </tr>
</table>



<h2 id="featuregroup">L.FeatureGroup</h2>

<p>是 <a href="#layergroup">LayerGroup</a> 的扩展，但多了鼠标事件和共享的弹出框方法。继承自 <a href="#ilayer">ILayer</a> 接口。</p>

<pre><code class="javascript">L.featureGroup([marker1, marker2, polyline])
    .bindPopup('Hello world!')
    .on('click', function() { alert('Clicked on a group!'); })
    .addTo(map);</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width300">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.FeatureGroup</b>(
            <nobr>&lt;<a href="#ilayer">ILayer</a>[]&gt; <i>layers?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.FeatureGroup(<span class="comment">&hellip;</span>)</code><br />
            <code>L.featureGroup(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>创建一个图组，视情况指定一组初始图层。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<p>具有 <a href="#layergroup">LayerGroup</a> 的方法，还有下面多出的方法:</p>

<table>
    <tr>
        <th class="width250">方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>bindPopup</b>(
            <nobr>&lt;String&gt; <i>htmlContent</i></nobr>,
            <nobr>&lt;<a href="#popup-options">Popup options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>组中任意具有 <code>bindPopup</code> 方法的图层上绑定一个具有具体HTML内容的弹出框。</td>
    </tr>
    <tr>
        <td><code><b>getBounds</b>()</code></td>
        <td><code><a href="#latlngbounds">LatLngBounds</a></code></td>
        <td>返回要素组的经纬度边界（通过他子图层的边界和坐标获得）。</td>
    </tr>
    <tr>
        <td><code><b>setStyle</b>(
            <nobr>&lt;<a href="#path-options">Path options</a>&gt; <i>style</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>设置组中具有 <code>setStyle</code> 方法的图层的路径选项。</td>
    </tr>
    <tr>
        <td><code><b>bringToFront</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>将图组置于顶层。</td>
    </tr>
    <tr>
        <td><code><b>bringToBack</b>()</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>将图组置于底层。</td>
    </tr>
</table>

<h3>Events（事件）</h3>

<table>
    <tr>
        <th class="width100">事件</th>
        <th class="width100">Data</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>click</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>用户点击或触摸组是触发。</td>
    </tr>
    <tr>
        <td><code><b>dblclick</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>用户双击或连续两次触摸组时触发。</td>
    </tr>
    <tr>
        <td><code><b>mouseover</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>当鼠标置于组上方时触发。</td>
    </tr>
    <tr>
        <td><code><b>mouseout</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>当鼠标离开组时触发。</td>
    </tr>
    <tr>
        <td><code><b>mousemove</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>当鼠标经过组时触发。</td>
    </tr>
    <tr>
        <td><code><b>contextmenu</b></code></td>
        <td><code><a href="#mouse-event">MouseEvent</a></code></td>
        <td>当用户右击图层时触发。</td>
    </tr>
    <tr>
        <td><code><b>layeradd</b></code></td>
        <td><code><a href="#layer-event">LayerEvent</a></code>
        <td>当图层被加入到组时触发。</td>
    </tr>
    <tr>
        <td><code><b>layerremove</b></code></td>
        <td><code><a href="#layer-event">LayerEvent</a></code>
        <td>当图层从组中移除时触发。</td>
    </tr>
</table>


<h2 id="geojson">L.GeoJSON</h2>

<p>展示一个 <a href="http://geojson.org/geojson-spec.html">GeoJSON</a> 的图层。允许你在地图上解析并显示GeoJSON数据。是 <a href="#featuregroup">FeatureGroup</a>的延伸。</p>

<pre><code class="javascript">L.geoJson(data, {
    style: function (feature) {
    return {color: feature.properties.color};
    },
    onEachFeature: function (feature, layer) {
    layer.bindPopup(feature.properties.description);
    }
    }).addTo(map);</code></pre>

<p>由此创建的每个要素层获取要素与之关联的GeoJSON数据属性（因此你随后可以传递它的属性）。</p>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th>构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.GeoJSON</b>(
            <nobr>&lt;Object&gt; <i>geojson?</i></nobr>,
            <nobr>&lt;<a href="#geojson-options">GeoJSON options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.GeoJSON(<span class="comment">&hellip;</span>)</code><br />
            <code>L.geoJson(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>创建一个GeoJSON图层。可以任意地接受 <a href="http://geojson.org/geojson-spec.html">GeoJSON 格式</a> 的对象和选项对象并显示在地图上（随后可以选择用 <code>addData</code> 方法添加）。</td>
    </tr>
</table>

<h3 id="geojson-options">Options（选项）</h3>

<table>
    <tr>
        <th>参数</th>
        <th>说明</th>
    </tr>
    <tr id="geojson-pointtolayer">
        <td><code><b>pointToLayer</b>(
            <nobr>&lt;GeoJSON&gt; <i>featureData</i></nobr>,
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i> )</nobr>
        </code></td>

        <td>在创建GeoJSON点图层时所用到的函数（如果不特意说明，会创建简单的注记）。</td>
    </tr>
    <tr id="geojson-style">
        <td><code><b>style</b>(
            <nobr>&lt;GeoJSON&gt; <i>featureData</i> )</nobr>
        </code></td>

        <td>在获取用来创建GeoJSON要素的矢量图层的样式选项时可以用到。</td>
    </tr>
    <tr id="geojson-oneachfeature">
        <td><code><b>onEachFeature</b>(
            <nobr>&lt;GeoJSON&gt; <i>featureData</i></nobr>,
            <nobr>&lt;<a href="#ilayer">ILayer</a>&gt; <i>layer</i> )</nobr>
        </code></td>

        <td>在每个创建的图层上都会调用此函数。对于向要素添加事件和弹出框比较有用。</td>
    </tr>
    <tr id="geojson-filter">
        <td><code><b>filter</b>(
            <nobr>&lt;GeoJSON&gt; <i>featureData</i></nobr>,
            <nobr>&lt;<a href="#ilayer">ILayer</a>&gt; <i>layer</i> )</nobr>
        </code></td>

        <td>用来决定是否显示某要素的函数。</td>
    </tr>
</table>


<h3>Methods（方法）</h3>

<table>
    <tr>
        <th class="width250">方法</th>
        <th class="minwidth">返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>addData</b>(
            <nobr>&lt;GeoJSON&gt; <i>data</i> )</nobr>
        </code></td>

        <td><code>Boolean</code></td>
        <td>在图层中添加GeoJSON对象。</td>
    </tr>
    <tr id="geojson-setstyle">
        <td><code><b>setStyle</b>(
            <nobr>&lt;Function&gt; <i><a href="#geojson-style">style</a></i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>通过给定的样式函数改变GeoJSON矢量图层的样式。</td>
    </tr>
    <tr id="geojson-resetstyle">
        <td><code><b>resetStyle</b>(
            <nobr>&lt;<a href="#path">Path</a>&gt; <i>layer</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将矢量图层样式重置为初始GeoJSON样式，对于hover事件之后的重置比较有用。</td>
    </tr>
</table>

<h3>Static methods（静态方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>geometryToLayer</b>(
            <nobr>&lt;GeoJSON&gt; <i>featureData</i></nobr>,
            <nobr>&lt;<a href="#geojson-pointtolayer">Function</a>&gt; <i>pointToLayer?</i> )</nobr>
        </code></td>

        <td><code><a href="#ilayer">ILayer</a></code></td>
        <td>通过给定的GeoJSON要素创建图层。</td>
    </tr>
    <tr>
        <td><code><b>coordsToLatlng</b>(
            <nobr>&lt;Array&gt; <i>coords</i></nobr>,
            <nobr>&lt;Boolean&gt; <i>reverse?</i> )</nobr>
        </code></td>

        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>通过在GeoJSON中表示点的两个数字组成（分别表示纬度和经度）的数组来创建经纬度对象。如果 <code>reverse</code> 设置为 <code><span class="literal">true</span></code>，那么这两个数字被颠倒，表经度和纬度。</td>
    </tr>
    <tr>
        <td><code><b>coordsToLatlngs</b>(
            <nobr>&lt;Array&gt; <i>coords</i></nobr>,
            <nobr>&lt;Number&gt; <i>levelsDeep?</i></nobr>,
            <nobr>&lt;Boolean&gt; <i>reverse?</i> )</nobr>
        </code></td>

        <td><code>Array</code></td>
        <td>通过GeoJSON坐标坐标的数组创建多维数组。 <code>levelsDeep</code> 指定具体的嵌套级别（0表示点的数组，1表示点数组的数组等等，0为默认值）。如果 <code>reverse</code> 设置为 <code><span class="literal">true</span></code>，这些数组变为经度和纬度。</td>
    </tr>
</table>




<h2 id="latlng">L.LatLng</h2>

<p>表示通过某一经度和纬度确定的地理上的点。</p>
<pre><code class="javascript">var latlng = new L.LatLng(50.5, 30.5);</code></pre>

<pre><code>map.panTo([50, 30]);
    map.panTo(new L.LatLng(50, 30));</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width200">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.LatLng</b>(
            <nobr>&lt;Number&gt; <i>latitude</i></nobr>,
            <nobr>&lt;Number&gt; <i>longitude</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.LatLng(<span class="comment">&hellip;</span>)</code><br />
            <code>L.latLng(<span class="comment">&hellip;</span>)</code><br />
            <code>L.latLng([<span class="comment">&hellip;</span>])</code>
        </td>

        <td>通过给定的纬度和经度创建表示地理点的对象。</td>
    </tr>
</table>

<h3>Properties</h3>

<table>
    <tr>
        <th class="width100">属性</th>
        <th class="width100">类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>lat</b></code></td>
        <td><code>Number</code></td>
        <td>以度数表示的纬度。</td>
    </tr>
    <tr>
        <td><code><b>lng</b></code></td>
        <td><code>Number</code></td>
        <td>以度数表示的经度。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>distanceTo</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>otherLatlng</i> )</nobr>
        </code></td>

        <td><code>Number</code></td>
        <td>返回到通过半正矢公式计算的经纬度的距离（用米表示）。</td>
    </tr>
    <tr>
        <td><code><b>equals</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>otherLatlng</i> )</nobr>
        </code></td>

        <td><code>Boolean</code></td>
        <td>如果给定的经纬度在相同的位置（具有较小的容差）则返回 <code><span class="literal">true</span></code> </td>
    </tr>
    <tr>
        <td><code><b>toString</b>()</code></td>
        <td><code>String</code></td>
        <td>返回点的描述信息（用来调试用）。</td>
    </tr>
    <tr>
        <td><code><b>wrap</b>(
            <nobr>&lt;Number&gt; <i>left</i></nobr>,
            <nobr>&lt;Number&gt; <i>right</i> )</nobr>
        </code></td>

        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>返回在 <code>LatLng</code> 上 <code>left</code> 和 <code>right</code> 边界覆盖范围内 (默认为 <code><span class="number">-180</span></code> 到 <code><span class="number">180</span></code> 的心的经纬度对象。).</td>
    </tr>
</table>

<h3>Constants（常量）</h3>

<table>
    <tr>
        <th class="width100">常量</th>
        <th class="width100">类型</th>
        <th class="width100">值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>DEG_TO_RAD</b></code></td>
        <td><code>Number</code></td>
        <td><code>Math.PI / <span class="number">180</span></code></td>
        <td>度数转换为弧度的乘子。</td>
    </tr>
    <tr>
        <td><code><b>RAD_TO_DEG</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">180</span> / Math.PI</code></td>
        <td>弧度转换为度数的乘子。</td>
    </tr>
    <tr>
        <td><code><b>MAX_MARGIN</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">1.0E-9</span></code></td>
        <td>判断相等的容差。</td>
    </tr>
</table>




<h2 id="latlngbounds">L.LatLngBounds</h2>

<p>表示地图上一个矩形的区域。</p>
<pre><code class="javascript">var southWest = new L.LatLng(40.712, -74.227),
    northEast = new L.LatLng(40.774, -74.125),
    bounds = new L.LatLngBounds(southWest, northEast);</code></pre>

<p>所有接受LatLngBounds对象的Leaflet方法也接受他们简单数组的形式（除非另行说明）。</p>

<pre><code class="javascript">map.fitBounds([
    [40.712, -74.227],
    [40.774, -74.125]
    ]);</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width250">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td>
            <code><b>L.LatLngBounds</b>(
                <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>southWest</i></nobr>,
                <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>northEast</i></nobr> )</code>
        </td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.LatLngBounds(<span class="comment">&hellip;</span>)</code><br />
            <code>L.latLngBounds(<span class="comment">&hellip;</span>)</code><br />
            <code>L.latLngBounds([<span class="comment">&hellip;</span>])</code>
        </td>

        <td>通过定义矩形西南角点和东北角点来创建经纬度的矩形框。</td>
    </tr>
    <tr>
        <td><code><b>L.LatLngBounds</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>[]&gt; <i>latlngs</i> )</nobr>
        </code></td>
        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.LatLngBounds(<span class="comment">&hellip;</span>)</code><br />
            <code>L.latLngBounds(<span class="comment">&hellip;</span>)</code>
        </td>
        <td>通过定义内在点来创建经纬度的矩形框。当用 <a href="#map-fitbounds">fitBounds</a>把地图放到适合某些位置的缩放级别时是比较有用的。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th class="width300">方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>extend</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>|<a href="#latlngbounds">LatLngBounds</a>&gt; <i>latlng</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将边界延伸到包含给定点和边界的范围。</td>
    </tr>
    <tr>
        <td><code><b>getSouthWest</b>()</code></td>
        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>返回边界的西南角点。</td>
    </tr>
    <tr>
        <td><code><b>getNorthEast</b>()</code></td>
        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>返回边界的东北角点。</td>
    </tr>
    <tr>
        <td><code><b>getNorthWest</b>()</code></td>
        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>返回边界的西北角点。</td>
    </tr>
    <tr>
        <td><code><b>getSouthEast</b>()</code></td>
        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>返回边界的东南角点。</td>
    </tr>
    <tr>
        <td><code><b>getWest</b>()</code></td>
        <td><code>Number</code></td>
        <td>返回边界的西点。</td>
    </tr>
    <tr>
        <td><code><b>getSouth</b>()</code></td>
        <td><code>Number</code></td>
        <td>返回边界的南角点。</td>
    </tr>
    <tr>
        <td><code><b>getEast</b>()</code></td>
        <td><code>Number</code></td>
        <td>返回边界的东角点。</td>
    </tr>
    <tr>
        <td><code><b>getNorth</b>()</code></td>
        <td><code>Number</code></td>
        <td>返回边界的北角点。</td>
    </tr>
    <tr>
        <td><code><b>getCenter</b>()</code></td>
        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>返回边界的中心点。</td>
    </tr>
    <tr>
        <td><code><b>contains</b>(
            <nobr>&lt;<a href="#latlngbounds">LatLngBounds</a>&gt; <i>otherBounds</i> )</nobr>
        </code></td>

        <td><code>Boolean</code></td>
        <td>如果矩形框包含给定的边界则返回 <code><span class="literal">true</span></code></td>
    </tr>
    <tr>
        <td><code><b>contains</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i> )</nobr>
        </code></td>

        <td><code>Boolean</code></td>
        <td>如果矩形框包含给定的点则返回 <code><span class="literal">true</span></code> 。</td>
    </tr>
    <tr>
        <td><code><b>intersects</b>(
            <nobr>&lt;<a href="#latlngbounds">LatLngBounds</a>&gt; <i>otherBounds</i> )</nobr>
        </code></td>

        <td><code>Boolean</code></td>
        <td>如果矩形框与给定的边界相交则返回 <code><span class="literal">true</span></code> 。</td>
    </tr>
    <tr>
        <td><code><b>equals</b>(
            <nobr>&lt;<a href="#latlngbounds">LatLngBounds</a>&gt; <i>otherBounds</i> )</nobr>
        </code></td>

        <td><code>Boolean</code></td>
        <td>如果矩形框与给定的范围相等（在一定容差范围内）则返回 <code><span class="literal">true</span></code> </td>
    </tr>
    <tr>
        <td><code><b>toBBoxString</b>()</code></td>
        <td><code>String</code></td>
        <td>返回 <code><span class="string">'southwest_lng,southwest_lat,northeast_lng,northeast_lat'</span></code> 形式的外接矩形的坐标。在向网络服务器提交请求返回地理数据时比较有用。</td>
    </tr>
    <tr>
        <td><code><b>pad</b>(
            <nobr>&lt;Number&gt; <i>bufferRatio</i> )</nobr>
        </code></td>

        <td><code><a href="#latlngbounds">LatLngBounds</a></code></td>
        <td>返回当前范围扩大一定百分比后的边界。</td>
    </tr>
    <tr>
        <td><code><b>isValid</b>()</nobr>
        </code></td>

        <td><code>Boolean</code></td>
        <td>如果边界可被初始化则返回 <code><span class="literal">true</span></code>。</td>
    </tr>
</table>




<h2 id="point">L.Point</h2>

<p>显示以像素为单位的点的x，y坐标。</p>

<pre><code>var point = new L.Point(200, 300);</code></pre>

<pre><code>map.panBy([200, 300]);
    map.panBy(new L.Point(200, 300));</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width250">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Point</b>(
            <nobr>&lt;Number&gt; <i>x</i>, &lt;Number&gt; <i>y</i></nobr>,
            <nobr>&lt;Boolean&gt; <i>round?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Point(<span class="comment">&hellip;</span>)</code><br />
            <code>L.point(<span class="comment">&hellip;</span>)</code><br />
            <code>L.point([<span class="comment">&hellip;</span>])</code>
        </td>

        <td>用给定点的x和y坐标来创建点对象。</td>
    </tr>
</table>

<h3>Properties（属性）</h3>

<table>
    <tr>
        <th class="width100">属性</th>
        <th class="width100">类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>x</b></code></td>
        <td><code>Number</code></td>
        <td>x坐标。</td>
    </tr>
    <tr>
        <td><code><b>y</b></code></td>
        <td><code>Number</code></td>
        <td>y坐标。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>add</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>otherPoint</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>返回当前点和给定点的和。</td>
    </tr>
    <tr>
        <td><code><b>subtract</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>otherPoint</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>返回当前点和给定点的差。</td>
    </tr>
    <tr>
        <td><code><b>multiplyBy</b>(
            <nobr>&lt;Number&gt; <i>number</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>返回当前点和给定值的积。</td>
    </tr>
    <tr>
        <td><code><b>divideBy</b>(
            <nobr>&lt;Number&gt; <i>number</i></nobr>,
            <nobr>&lt;Boolean&gt; <i>round?</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>返回当前点和给定值的商。如果 <code>round</code> 设置为 <code><span class="literal">true</span></code>，则返回一个圆的结果。</td>
    </tr>
    <tr>
        <td><code><b>distanceTo</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>otherPoint</i> )</nobr>
        </code></td>

        <td><code>Number</code></td>
        <td>返回当前点与给定的的距离。</td>
    </tr>
    <tr>
        <td><code><b>clone</b>()</code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td>返回当前的副本。</td>
    </tr>
    <tr>
        <td><code><b>round</b>()</code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td>返回当前的在圆上的坐标的副本。</td>
    </tr>
    <tr>
        <td><code><b>equals</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>otherPoint</i> )</nobr>
        </code></td>

        <td><code>Boolean</code></td>
        <td>如果点坐标相同则返回 <code><span class="literal">true</span></code></td>
    </tr>
    <tr>
        <td><code><b>toString</b>()</code></td>
        <td><code>String</code></td>
        <td>在调试时显示点的字符串的形式。</td>
    </tr>
</table>



<h2 id="bounds">L.Bounds</h2>

<p>用像素坐标表示的矩形的区域。</p>
<pre><code class="javascript">var p1 = new L.Point(10, 10),
    p2 = new L.Point(40, 60),
    bounds = new L.Bounds(p1, p2);</code></pre>

<pre><code class="javascript">otherBounds.intersects([[10, 10], [40, 60]]);</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width250">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Bounds</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>topLeft</i></nobr>,
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>bottomRight</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Bounds(<span class="comment">&hellip;</span>)</code><br />
            <code>L.bounds(<span class="comment">&hellip;</span>)</code><br />
            <code>L.bounds([<span class="comment">&hellip;</span>])</code>
        </td>

        <td>用两个坐标（通常是左上角的点和右下角的点）来创建边界对象。</td>
    </tr>
    <tr>
        <td><code><b>L.Bounds</b>(
            <nobr>&lt;<a href="#point">Point</a>[]&gt; <i>points</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Bounds(<span class="comment">&hellip;</span>)</code><br />
            <code>L.bounds(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>用包含的点创建边界对象。</td>
    </tr>
</table>

<h3>Properties（属性）</h3>

<table>
    <tr>
        <th class="width100">属性</th>
        <th class="width100">类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>min</b></code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td>矩形左上角点。</td>
    </tr>
    <tr>
        <td><code><b>max</b></code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td>矩形右下角点。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th class="width250">方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>extend</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>point</i> )</nobr>
        </code></td>

        <td>-</td>
        <td>将包含给定点的边界延伸。</td>
    </tr>
    <tr>
        <td><code><b>getCenter</b>()</code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td>返回边界的中心点。</td>
    </tr>
    <tr>
        <td><code><b>contains</b>(
            <nobr>&lt;<a href="#bounds">Bounds</a>&gt; <i>otherBounds</i> )</nobr>
        </code></td>

        <td><code>Boolean</code></td>
        <td>如果矩形包含给定的边界则返回 <code><span class="literal">true</span></code>。</td>
    </tr>
    <tr>
        <td><code><b>contains</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>point</i> )</nobr>
        </code></td>

        <td><code>Boolean</code></td>
        <td>如果矩形包含给定点则返回 <code><span class="literal">true</span></code>。</td>
    </tr>
    <tr>
        <td><code><b>intersects</b>(
            <nobr>&lt;<a href="#bounds">Bounds</a>&gt; <i>otherBounds</i> )</nobr>
        </code></td>

        <td><code>Boolean</code></td>
        <td>如果矩形与给定边界相交则返回 <code><span class="literal">true</span></code>。</td>
    </tr>
    <tr>
        <td><code><b>isValid</b>()</code></td>

        <td><code>Boolean</code></td>
        <td>如果边界可以被初始化则返回 <code><span class="literal">true</span></code>。</td>
    </tr>
    <tr>
        <td><code><b>getSize</b>()</code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>返回边界的大小。</td>
    </tr>
</table>


<h2 id="icon">L.Icon</h2>

<p>创建注记时显示的图标。</p>

<pre><code class="javascript">var myIcon = L.icon({
    iconUrl: 'my-icon.png',
    iconRetinaUrl: 'my-icon@2x.png',
    iconSize: [38, 95],
    iconAnchor: [22, 94],
    popupAnchor: [-3, -76],
    shadowUrl: 'my-icon-shadow.png',
    shadowRetinaUrl: 'my-icon-shadow@2x.png',
    shadowSize: [68, 95],
    shadowAnchor: [22, 94]
    });

    L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);</code></pre>


<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width250">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Icon</b>(
            <nobr>&lt;<a href="#icon-options">Icon options</a>&gt; <i>options</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Icon(<span class="comment">&hellip;</span>)</code><br />
            <code>L.icon(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>通过给定的选项创建图标实例。</td>
    </tr>
</table>

<h3 id="icon-options">Options（选项）</h3>

<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>iconUrl</b></code></td>
        <td><code>String</code>
        <td>请求图标图片的URL（脚本中的绝对或相对路径）。</td>
    </tr>
    <tr>
        <td><code><b>iconRetinaUrl</b></code></td>
        <td><code>String</code>
        <td>图标图片视网膜视图下的尺寸的URL。用于视网膜屏幕的设备。</td>
    </tr>
    <tr>
        <td><code><b>iconSize</b></code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td>图标图片的像素大小。</td>
    </tr>
    <tr>
        <td><code><b>iconAnchor</b></code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td>图标提示的坐标（在左上角）。图标是对其的，所以这个点是注记的地理位置。如果大小是指定的则位于中心处，也可以在CSS中设置负边界。</td>
    </tr>
    <tr>
        <td><code><b>shadowUrl</b></code></td>
        <td><code>String</code>
        <td>图标阴影图的URL。如果没有指定，图标没有阴影。</td>
    </tr>
    <tr>
        <td><code><b>shadowRetinaUrl</b></code></td>
        <td><code>String</code>
        <td>图标在视网膜视图下的尺寸的URL。如果没有指定，图标没有阴影。用于视网膜屏幕的设备。</td>
    </tr>
    <tr>
        <td><code><b>shadowSize</b></code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td>阴影长度</td>
    </tr>
    <tr>
        <td><code><b>shadowAnchor</b></code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td>阴影的提示坐标（在左上角）（如果没有指定则与 <code>iconAnchor</code> 相同）。</td>
    </tr>
    <tr>
        <td><code><b>popupAnchor</b></code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td>与图标锚相关的打开弹出框的点的坐标。</td>
    </tr>
    <tr>
        <td><code><b>className</b></code></td>
        <td><code>String</code>
        <td>图标和阴影图片的自定义的类名。默认为空。</td>
    </tr>
</table>


<h2 id="divicon">L.DivIcon</h2>

<p>用 <code>div</code> 元素而非图片来轻量级地显示注记的图标。</p>

<pre><code class="javascript">var myIcon = L.divIcon({className: 'my-div-icon'});
    // you can set .my-div-icon styles in CSS

    L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);</code></pre>

<p>默认情况下，阴影会有一个小的白色的方形作为 <code><span class="string">'ocean-div-icon'</span></code> 类和样式。</p>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width250">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.DivIcon</b>(
            <nobr>&lt;<a href="#divicon-options">DivIcon options</a>&gt; <i>options</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.DivIcon(<span class="comment">&hellip;</span>)</code><br />
            <code>L.divIcon(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>用给定的选项实例化图标。</td>
    </tr>
</table>

<h3 id="divicon-options">Options（选项）</h3>

<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>iconSize</b></code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td>图标的像素大小。也可以通过CSS设置。</td>
    </tr>
    <tr>
        <td><code><b>iconAnchor</b></code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td>图标提示的坐标（在左上角）。图标是对其的，所以这个点是注记的地理位置。如果大小是指定的则位于中心处，也可以在CSS中设置负边界。</td>
    </tr>
    <tr>
        <td><code><b>className</b></code></td>
        <td><code>String</code>
        <td>用于对其图标的自定义的类名，默认为 <code><span class="string">'ocean-div-icon'</span></code> 。</td>
    </tr>
    <tr>
        <td><code><b>html</b></code></td>
        <td><code>String</code>
        <td>在div元素中自定义的HTML代码，默认为空。</td>
    </tr>
</table>




<h2 id="control">L.Control</h2>

<p>所有 Leaflet控制的基础类。继承自 <a href="#icontrol">IControl</a>接口。</p>

<pre><code>control.addTo(map);
    // the same as
    map.addControl(control);</code></pre>

<h3>Constructor（函数构造器）</h3>
<table>
    <tr>
        <th class="width300">构造函数</th>
        <th class="minwidth">Usage</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Control</b>(
            <nobr>&lt;<a href="#control-options">Control options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Control(<span class="comment">&hellip;</span>)</code><br />
            <code>L.control(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>通过给定的选项创建一个控制。</td>
    </tr>
</table>

<h3>Options（选项）</h3>
<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>position</b></code></td>
        <td><code>String</code></td>
        <td><code><span class="string">'topright'</span></code></td>
        <td>控制初始的位置（在地图的某一角）。参见 <a href="#control-positions">control positions</a>.</td>
    </tr>
</table>

<h3>Methods（方法）</h3>
<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>setPosition</b>(
            <nobr>&lt;String&gt; <i>position</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>设置控制的位置。参见 <a href="#control-positions">control positions</a>。</td>
    </tr>
    <tr>
        <td><code><b>getPosition</b>()</code></td>
        <td><code>String</code></td>
        <td>返回控制的当前位置。</td>
    </tr>
    <tr>
        <td><code><b>addTo</b>(
            <nobr>&lt;<a href="#map">Map</a>&gt; <i>map</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将控制添加到地图上。</td>
    </tr>
    <tr>
        <td><code><b>removeFrom</b>(
            <nobr>&lt;<a href="#map">Map</a>&gt; <i>map</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将控制从地图上移除。</td>
    </tr>
</table>

<h3 id="control-positions">Control Positions（控制的位置）</h3>

<table>
    <tr>
        <th class="minwidth">Position</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><span class="string">'topleft'</span></code></td>
        <td>地图的左上角。</td>
    </tr>
    <tr>
        <td><code><span class="string">'topright'</span></code></td>
        <td>地图的右上角。</td>
    </tr>
    <tr>
        <td><code><span class="string">'bottomleft'</span></code></td>
        <td>地图的左下角。</td>
    </tr>
    <tr>
        <td><code><span class="string">'bottomright'</span></code></td>
        <td>地图的右下角。</td>
    </tr>
</table>


<h2 id="control-zoom">L.Control.Zoom</h2>

<p>拥有两个按钮（放大和缩小）的级别的缩放控制。默认地图上是有的，除非设置 <code>zoomControl</code> 选项为 <code><span class="literal">false</span></code>，扩展自 <a href="#control">Control</a>.</p>

<h3>Constructor（函数构造器）</h3>
<table>
    <tr>
        <th>构造函数</th>
        <th>用法</th>
        <th class="width200">说明</th>
    </tr>
    <tr>
        <td><code><b>L.Control.Zoom</b>(
            <nobr>&lt;<a href="#control-zoom-options">Control.Zoom options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Control.Zoom(<span class="comment">&hellip;</span>)</code><br />
            <code>L.control.zoom(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>创建缩放控制。</td>
    </tr>
</table>

<h3 id="control-zoom-options">Options（选项）</h3>
<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>position</b></code></td>
        <td><code>String</code></td>
        <td><code><span class="string">'topleft'</span></code></td>
        <td>控制的位置（在地图的某一角）。参见 <a href="#control-positions">control positions</a>.</td>
    </tr>
</table>



<h2 id="control-attribution">L.Control.Attribution</h2>

<p>可以在地图上一个小的文本盒子中显示属性数据的属性控制。默认地图上是有的，除非设置 <code>attributionControl</code> 选项为 <code><span class="literal">false</span></code>，并且它自动地通过 <code>getAttribution</code> 方法获取图层的属性文本。继承自 <a href="#control">Control</a>.</p>

<h3>Constructor（函数构造器）</h3>
<table>
    <tr>
        <th class="width200">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Control.Attribution</b>(
            <nobr>&lt;<a href="#control-attribution-options">Control.Attribution options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Control.Attribution(<span class="comment">&hellip;</span>)</code><br />
            <code>L.control.attribution(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>创建属性控制。</td>
    </tr>
</table>

<h3 id="control-attribution-options">Options（选项）</h3>
<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>position</b></code></td>
        <td><code>String</code></td>
        <td><code><span class="string">'bottomright'</span></code></td>
        <td>控制的位置（在地图的某一角）。参见 <a href="#control-positions">control positions</a>.</td>
    </tr>
    <tr>
        <td><code><b>prefix</b></code></td>
        <td><code>String</code></td>
        <td><code><span class="string">'Powered by Leaflet'</span></code></td>
        <td>在属性之前显示的HTML文本。传递 <code><span class="literal">false</span></code>来使其不显示。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>
<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>setPrefix</b>(
            <nobr>&lt;String&gt; <i>prefix</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>在属性之前设置文本。</td>
    </tr>
    <tr>
        <td><code><b>addAttribution</b>(
            <nobr>&lt;String&gt; <i>text</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>添加属性文本。</td>
    </tr>
    <tr>
        <td><code><b>removeAttribution</b>(
            <nobr>&lt;String&gt; <i>text</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>移除属性文本。</td>
    </tr>
</table>


<h2 id="control-layers">L.Control.Layers</h2>

<p>图层控制使用户可以在不同的底图之间切换，并可以控制覆盖物的开关。继承自 <a href="#control">Control</a>.</p>

<pre><code>var baseLayers = {
    "CloudMade": cloudmade,
    "OpenStreetMap": osm
    };

    var overlays = {
    "Marker": marker,
    "Roads": roadsLayer
    };

    L.control.layers(baseLayers, overlays).addTo(map);</code></pre>

<h3>Constructor（函数构造器）</h3>
<table>
    <tr>
        <th>构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Control.Layers</b>(
            <nobr>&lt;<a href="#control-layers-config">Layer Config</a>&gt; <i>baseLayers?</i></nobr>,
            <nobr>&lt;<a href="#control-layers-config">Layer Config</a>&gt; <i>overlays?</i></nobr>,
            <nobr>&lt;<a href="#control-layers-options">Control.Layers options</a>&gt; <i>options?</i> )</nobr>
        </code></td>
        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Control.Layers(<span class="comment">&hellip;</span>)</code><br />
            <code>L.control.layers(<span class="comment">&hellip;</span>)</code>
        </td>
        <td>通过给定的图层创建数据控制。基础图层通过单选项进行切换，覆盖物通过复选框切换显示。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>
<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>addBaseLayer</b>(
            <nobr>&lt;<a href="#ilayer">ILayer</a>&gt; <i>layer</i></nobr>,
            <nobr>&lt;String&gt; <i>name</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>通过给定的控制名称添加基础层（通过单选按钮实体）。</td>
    </tr>
    <tr>
        <td><code><b>addOverlay</b>(
            <nobr>&lt;<a href="#ilayer">ILayer</a>&gt; <i>layer</i></nobr>,
            <nobr>&lt;String&gt; <i>name</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>凸显给定的控制名称添加覆盖物（通过复选框实体）。</td>
    </tr>
    <tr>
        <td><code><b>removeLayer</b>(
            <nobr>&lt;<a href="#ilayer">ILayer</a>&gt; <i>layer</i> )</nobr>
        </code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td>将图层从控制中移除。</td>
    </tr>
</table>

<h3 id="control-layers-options">Options（选项）</h3>

<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>position</b></code></td>
        <td><code>String</code></td>
        <td><code><span class="string">'topright'</span></code></td>
        <td>控制的位置（在地图的某一角）。参见 <a href="#control-positions">control positions</a>.</td>
    </tr>
    <tr>
        <td><code><b>collapsed</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>如果为 <code><span class="literal">true</span></code>，控制可以收缩为一个图标，在鼠标置于上方或点触时展开。</td>
    </tr>
    <tr>
        <td><code><b>autoZIndex</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>如果为 <code><span class="literal">true</span></code>，控制的图层升序地叠置对齐，在切换图层打开或关闭时，顺便不变。</td>
    </tr>
</table>


<h3 id="control-layers-config">Layer Config</h3>

<p>An object literal with layer names as keys and layer objects as values:</p>

<pre><code>{
    "&lt;someName1&gt;": layer1,
    "&lt;someName2&gt;": layer2
    }</code></pre>

<p>The layer names can contain HTML, which allows you to add additional styling to the items:</p>

<pre><code>{"&lt;img src='my-layer-icon' /&gt; &lt;span class='my-layer-item'&gt;My Layer&lt;/span&gt;": myLayer}</code></pre>


<h3>Events（事件）</h3>

<table>
    <tr>
        <th class="width100">事件</th>
        <th class="width100">Data</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>baselayerchange</b></code></td>
        <td><code><a href="#layer-event">LayerEvent</a></code>
        <td>当基层层通过控制更改时触发。</td>
    </tr>
    <tr>
        <td><code><b>overlayadd</b></code></td>
        <td><code><a href="#layer-event">LayerEvent</a></code>
        <td>当图层添加时触发。</td>
    </tr>
    <tr>
        <td><code><b>overlayremove</b></code></td>
        <td><code><a href="#layer-event">LayerEvent</a></code>
        <td>当图层移除时触发。</td>
    </tr>
</table>


<h2 id="control-scale">L.Control.Scale</h2>

<p>显示在十进制或公制的屏幕当前中心的比例的简单比例尺控制。继承自 <a href="#icontrol">IControl</a> 接口。</p>

<pre><code>L.control.scale().addTo(map);</code></pre>

<h3>Constructor（函数构造器）</h3>
<table>
    <tr>
        <th class="width200">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Control.Scale</b>(
            <nobr>&lt;<a href="#control-scale-options">Control.Scale options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Control.Scale(<span class="comment">&hellip;</span>)</code><br />
            <code>L.control.scale(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>通过选项创建比例控制。</td>
    </tr>
</table>

<h3 id="control-scale-options">Options（选项）</h3>

<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>position</b></code></td>
        <td><code>String</code></td>
        <td><code><span class="string">'bottomleft'</span></code></td>
        <td>控制的位置（在地图的某一角）。参见 <a href="#control-positions">control positions</a>.</td>
    </tr>
    <tr>
        <td><code><b>maxWidth</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="number">100</span></code></td>
        <td>控制最大的像素宽度。宽度可以围绕几个值动态设置。</td>
    </tr>
    <tr>
        <td><code><b>metric</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>是否显示十进制比例线。 (m/km).</td>
    </tr>
    <tr>
        <td><code><b>imperial</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code></td>
        <td>是否显示公制比例线。 (mi/ft).</td>
    </tr>
    <tr>
        <td><code><b>updateWhenIdle</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">false</span></code></td>
        <td>如果设置为 <code><span class="literal">true</span></code> 控制由 <code>moveend</code> 更新，否则它总是最新的（由 <code>move</code> 更新）。</td>
    </tr>
</table>



<h2 id="events">Events methods</h2>

<p>一系列事件驱动的类（比如map）之间共享的方法。通常，事件允许你在一个对象发生某些事情时执行一些函数。</p>

<h3>示例</h3>

<pre><code class="javascript">map.on('click', function(e) {
    alert(e.latlng);
    });</code></pre>

<p>Leaflet 通过引用来处理事件监听器，所以如果你想咬添加或移除一个监听器时，可以用函数的方法:</p>

<pre><code>function onClick(e) { ... }

    map.on('click', onClick);
    map.off('click', onClick);</code></pre>

<h3>Methods（方法）</h3>
<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>addEventListener</b>(
            <nobr>&lt;String&gt; <i>type</i></nobr>,
            <nobr>&lt;Function&gt; <i>fn</i></nobr>,
            <nobr>&lt;Object&gt; <i>context?</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>向某一类型的事件中添加监听器函数。你可以选择性地指定监听器的内容（对象中 <code><span class="keyword">this</span></code> 关键字会被使用）。你也可以传递几个空格间隔的类型（如 <code><span class="string">'click dblclick'</span></code>)。</td>
    </tr>
    <tr>
        <td><code><b>addEventListener</b>(
            <nobr>&lt;Object&gt; <i>eventMap</i></nobr>,
            <nobr>&lt;Object&gt; <i>context?</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>添加一系列的类型/监听器对，如 <code>{click: onClick, mousemove: onMouseMove}</code></td>
    </tr>
    <tr>
        <td><code><b>removeEventListener</b>(
            <nobr>&lt;String&gt; <i>type</i></nobr>,
            <nobr>&lt;Function&gt; <i>fn?</i></nobr>,
            <nobr>&lt;Object&gt; <i>context?</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>移除之前添加的监听器函数。如果没有指定具体的函数，则所以的都会被移除。</td>
    </tr>
    <tr>
        <td><code><b>removeEventListener</b>(
            <nobr>&lt;Object&gt; <i>eventMap</i></nobr>,
            <nobr>&lt;Object&gt; <i>context?</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>移除一系列类型/监听器对。</code></td>
    </tr>
    <tr>
        <td><code><b>hasEventListeners</b>(
            <nobr>&lt;String&gt; <i>type</i> )</nobr>
        </code></td>

        <td><code>Boolean</code></td>
        <td>如果某一事件类型有附属的监听器则返回 <code><span class="literal">true</span></code></td>
    </tr>
    <tr>
        <td><code><b>fireEvent</b>(
            <nobr>&lt;String&gt; <i>type</i></nobr>,
            <nobr>&lt;Object&gt; <i>data?</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>触发指定类型的事件。你可以提供一个数据对象——监听器对象的第一个参数应该包含它的属性。</td>
    </tr>
    <tr>
        <td><code><b>on</b>( &hellip; )</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td><code>addEventListener</code>的别称。</td>
    </tr>
    <tr>
        <td><code><b>off</b>( &hellip; )</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td><code>removeEventListener</code>的别称。</td>
    </tr>
    <tr>
        <td><code><b>fire</b>( &hellip; )</code></td>
        <td><code><span class="keyword">this</span></code></td>
        <td><code>fireEvent</code>的别称。</td>
    </tr>
</table>


<h2 id="event-objects">Event objects</h2>

<p>当一些事件触发时接受监听器函数参数的事件对象，它包含了事件一些有用的信息。</p>

<pre><code class="javascript">map.on('click', function(e) {
    alert(e.latlng); // e is an event object (MouseEvent in this case)
    });</code></pre>

<h3 id="event">Event（事件）</h3>

<table>
    <tr>
        <th class="width100">属性</th>
        <th class="width100">类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>type</b></code></td>
        <td><code>String</code></td>
        <td>事件的类型。 (e.g. <code><span class="string">'click'</span></code>).</td>
    </tr>
    <tr>
        <td><code><b>target</b></code></td>
        <td><code>Object</code></td>
        <td>触发事件的对象。</td>
    </tr>
</table>

<h3 id="mouse-event">MouseEvent（鼠标事件）</h3>

<table>
    <tr>
        <th class="width100">属性</th>
        <th>类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>latlng</b></code></td>
        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>鼠标事件发生的地理点。</td>
    </tr>
    <tr>
        <td><code><b>layerPoint</b></code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td>鼠标事件发生的与地图图层相关的点的像素坐标。</td>
    </tr>
    <tr>
        <td><code><b>containerPoint</b></code></td>
        <td><code><a href="#point">Point</a></code></td>
        <td>鼠标事件发生的与地图容器相关的点的像素坐标。</td>
    </tr>
    <tr>
        <td><code><b>originalEvent</b></code></td>
        <td><code>DOMMouseEvent</code></td>
        <td>由浏览器触发的原始的DOM鼠标事件。</td>
    </tr>
</table>

<h3 id="location-event">LocationEvent（位置事件）</h3>

<table>
    <tr>
        <th class="width100">属性</th>
        <th>类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>latlng</b></code></td>
        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>监测到的用户的地理位置。</td>
    </tr>
    <tr>
        <td><code><b>bounds</b></code></td>
        <td><code><a href="#latlngbounds">LatLngBounds</a></code></td>
        <td>用户坐落的区域的地理边界（考虑位置精度问题）。</td>
    </tr>
    <tr>
        <td><code><b>accuracy</b></code></td>
        <td><code>Number</code></td>
        <td>米为单位的位置的精度。</td>
    </tr>
    <tr>
        <td><code><b>altitude</b></code></td>
        <td><code>Number</code></td>
        <td>Height of the position above the WGS84 ellipsoid in meters.</td>
    </tr>
    <tr>
        <td><code><b>altitudeAccuracy</b></code></td>
        <td><code>Number</code></td>
        <td>Accuracy of altitude in meters.</td>
    </tr>
    <tr>
        <td><code><b>heading</b></code></td>
        <td><code>Number</code></td>
        <td>The direction of travel in degrees counting clockwise from true North.</td>
    </tr>
    <tr>
        <td><code><b>altitude</b></code></td>
        <td><code>Number</code></td>
        <td>Height in meters of the position above the WGS84 ellipsoid.</td>
    </tr>
    <tr>
        <td><code><b>speed</b></code></td>
        <td><code>Number</code></td>
        <td>Current velocity in meters per second.</td>
    </tr>
    <tr>
        <td><code><b>timestamp</b></code></td>
        <td><code>Number</code></td>
        <td>The time when the position was acquired.</td>
    </tr>
</table>

<h3 id="error-event">ErrorEvent（错误事件）</h3>

<table>
    <tr>
        <th class="width100">属性</th>
        <th class="width100">类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>message</b></code></td>
        <td><code>String</code></td>
        <td>错误信息。</td>
    </tr>
    <tr>
        <td><code><b>code</b></code></td>
        <td><code>Number</code></td>
        <td>错误代码（若可用）。</td>
    </tr>
</table>

<h3 id="layer-event">LayerEvent（图层事件）</h3>

<table>
    <tr>
        <th class="width100">属性</th>
        <th class="width100">类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>layer</b></code></td>
        <td><code><a href="#ilayer">ILayer</a></code></td>
        <td>添加或移除的图层。</td>
    </tr>
</table>

<h3 id="tile-event">TileEvent（切片事件）</h3>

<table>
    <tr>
        <th class="width100">属性</th>
        <th class="width100">类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>tile</b></code></td>
        <td><code>HTMLElement</code></td>
        <td>切片要素（图片）。</td>
    </tr>
    <tr>
        <td><code><b>url</b></code></td>
        <td><code>String</code></td>
        <td>切片的url资源。</td>
    </tr>
</table>

<h3 id="geojson-event">GeoJSON event（GeoJSON事件）</h3>

<table>
    <tr>
        <th class="width100">属性</th>
        <th class="width100">类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>layer</b></code></td>
        <td><code><a href="#ilayer">ILayer</a></code></td>
        <td>将要添加到地图上的GeoJSON要素的图层。</td>
    </tr>
    <tr>
        <td><code><b>properties</b></code></td>
        <td><code>Object</code></td>
        <td>要素的GeoJSON的属性。</td>
    </tr>
    <tr>
        <td><code><b>geometryType</b></code></td>
        <td><code>String</code></td>
        <td>要素的GeoJSON的几何类型。</td>
    </tr>
    <tr>
        <td><code><b>id</b></code></td>
        <td><code>String</code></td>
        <td>要素的GeoJSON的ID（如果出现）。</td>
    </tr>
</table>

<h3 id="popup-event">Popup event（弹出框事件）</h3>

<table>
    <tr>
        <th class="width100">属性</th>
        <th class="width100">类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>popup</b></code></td>
        <td><code><a href="#popup">Popup</a></code></td>
        <td>打开或关闭的弹出框。</td>
    </tr>
</table>

<!-- <h3>TileEvent</h3> -->



<h2 id="class">L.Class</h2>

<p><code>L.Class</code> 强化了 Leaflet 的面向对象的设备并被用于创建几乎所哟这里提到的 Leaflet 类。</p>
<p>除了执行一个简单的类接口模型，它还引入了方便代码组织的一下特殊的属性 &mdash; <code>options</code> ， <code>includes</code> ， <code>statics</code>.</p>

<pre><code>var MyClass = L.Class.extend({
    initialize: function (greeter) {
    this.greeter = greeter;
    // class constructor
    },

    greet: function (name) {
    alert(this.greeter + ', ' + name)
    }
    });

    // create instance of MyClass, passing "Hello" to the constructor
    var a = new MyClass("Hello");

    // call greet method, alerting "Hello, World"
    a.greet("World");
</code></pre>

<h3>Inheritance（继承）</h3>

<p>可以用 <code>L.Class.extend</code> 来定义新的类，但可以在任何一个类上用同样的方法来继承它:</p>

<pre><code>var MyChildClass = MyClass.extend({
    // ... new properties and methods
    });</code></pre>

<p>这会创建一个继承父类所有方法和属性的类（由规范所约束），添加或重构你用来扩展的类。这也对 <code>instanceof</code>做出反应。:</p>

<pre><code>var a = new MyChildClass();
    a instanceof MyChildClass; // true
    a instanceof MyClass; // true
</code></pre>

<p>你可以通过父类的规范和javascript的call与apply来调用父类的方法来响应子类的方法（就像你在其他语言中调用超类）:</p>

<pre><code>var MyChildClass = MyClass.extend({
    initialize: function () {
    MyClass.prototype.initialize.call("Yo");
    },

    greet: function (name) {
    MyClass.prototype.greet.call(this, 'bro ' + name + '!');
    }
    });

    var a = new MyChildClass();
    a.greet('Jason'); // alerts "Yo, bro Jason!"</code></pre>

<h3 id="class-options">Options（选项）</h3>

<p><code>options</code> 是一个与其他对象不同的特殊的属性，其他你用来扩展的对象会被父类合并而非完全重构，这使管理对象的结构和默认值更加方便:</p>

<pre><code>var MyClass = L.Class.extend({
    options: {
    myOption1: 'foo',
    myOption2: 'bar'
    }
    });

    var MyChildClass = L.Class.extend({
    options: {
    myOption1: 'baz',
    myOption3: 5
    }
    });

    var a = new MyChildClass();
    a.options.myOption1; // 'baz'
    a.options.myOption2; // 'bar'
    a.options.myOption3; // 5</code></pre>

<p>选项中还有 <code>L.Util.setOptions</code>方法，可以方便地合并传递给函数构造器的选项和类中默认的定义:</p>

<pre><code>var MyClass = L.Class.extend({
    options: {
    foo: 'bar',
    bla: 5
    },

    initialize: function (options) {
    L.Util.setOptions(this, options);
    ...
    }
    });

    var a = new MyClass({bla: 10});
    a.options; // {foo: 'bar', bla: 10}</code></pre>

<h3>Includes（包含）</h3>

<p><code>includes</code> 是一个特殊的类，它将所有对象合并到一个类中。一个较好的例子是 <code>L.Mixin.Events</code> ，它是具有 <code>on</code>, <code>off</code> and <code>fire</code> 这些事件相关的方法的类。</p>

<pre><code> var MyMixin = {
    foo: function () { ... },
    bar: 5
    };

    var MyClass = L.Class.extend({
    includes: MyMixin
    });

    var a = new MyClass();
    a.foo();</code></pre>

<p>You can also do such includes in runtime with the <code>include</code> method:</p>

<pre><code><b>MyClass.include</b>(MyMixin);</code></pre>

<h3>Statics（静态）</h3>

<p><code>statics</code> 是一种方便的属性，将类中指定对象的属性变为静态属性，对于定义常量比较有用:</p>

<pre><code>var MyClass = L.Class.extend({
    statics: {
    FOO: 'bar',
    BLA: 5
    }
    });

    MyClass.FOO; // 'bar'</code></pre>


<h3>Class Factories（类工厂）</h3>

<p>你可以用个两种方式来创建 Leaflet class 的实例——用 <code>new</code> 关键字和用小写的factory方法:</p>

<pre><code>new L.Map('map');
    L.map('map');</code></pre>

<p>The second way is implemented very easily, and you can do this for your own classes:</p>

<pre><code>L.map = function (id, options) {
    return new L.Map(id, options);
    };</code></pre>


<h3>Constructor Hooks（构造函数钩子）</h3>

<p>如果你是一个插件开发者，你通常需要在现有的类中加入附件的初始化代码（比如因 <code>L.Polyline</code> 而编辑钩子）。 Leaflet 可以用 <code>addInitHook</code> 方法来简化它:</p>

<pre><code>MyClass.addInitHook(function () {
    // ... do something in constructor additionally
    // e.g. add event listeners, set custom properties etc.
    });</code></pre>

<p>You can also use the following shortcut when you just need to make one additional method call:</p>

<pre><code>MyClass.addInitHook('methodName', arg1, arg2, &hellip;);</code></pre>


<h2 id="browser">L.Browser</h2>

<p>内部监测浏览器或要素的带有属性的命名空间。</p>

<pre><code>if (L.Browser.ie6) {
    alert('Upgrade your browser, dude!');
    }</code></pre>

<table>
    <tr>
        <th class="width100">属性</th>
        <th class="width100">类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>ie</b></code></td>
        <td><code>Boolean</code></td>
        <td>如果是IE浏览器则返回 <code><span class="literal">true</span></code></td>
    </tr>
    <tr>
        <td><code><b>ie6</b></code></td>
        <td><code>Boolean</code></td>
        <td>如果是IE6浏览器则返回 <code><span class="literal">true</span></code></td>
    </tr>
    <tr>
        <td><code><b>ie7</b></code></td>
        <td><code>Boolean</code></td>
        <td>如果是IE7浏览器则返回<code><span class="literal">true</span></code></td>
    </tr>
    <tr>
        <td><code><b>webkit</b></code></td>
        <td><code>Boolean</code></td>
        <td>如果是类似chrome和safari的基于webkit的浏览器（包括移动版）则返回 <code><span class="literal">true</span></code></td>
    </tr>
    <tr>
        <td><code><b>webkit3d</b></code></td>
        <td><code>Boolean</code></td>
        <td>如果基于webkit的浏览器支持CSS的3D转换则返回 <code><span class="literal">true</span></code> </td>
    </tr>
    <!--<tr>
        <td><code><b>gecko</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code> for Gecko-based browsers like Firefox and Mozilla.</td>
    </tr>
    <tr>
        <td><code><b>opera</b></code></td>
        <td><code>Boolean</code></td>
        <td><code><span class="literal">true</span></code> for Opera.</td>
    </tr>-->
    <tr>
        <td><code><b>android</b></code></td>
        <td><code>Boolean</code></td>
        <td>如果是安卓移动版的浏览器则返回 <code><span class="literal">true</span></code></td>
    </tr>
    <tr>
        <td><code><b>android23</b></code></td>
        <td><code>Boolean</code></td>
        <td>如果是安卓2或3的浏览器则返回 <code><span class="literal">true</span></code></td>
    </tr>
    <tr>
        <td><code><b>mobile</b></code></td>
        <td><code>Boolean</code></td>
        <td>如果是流行的移动版的浏览器（包括iOS下的safari和其他各种安卓浏览器）则返回 <code><span class="literal">true</span></code></td>
    </tr>
    <tr>
        <td><code><b>mobileWebkit</b></code></td>
        <td><code>Boolean</code></td>
        <td>如果是移动版的基于webkit的浏览器则返回 <code><span class="literal">true</span></code></td>
    </tr>
    <tr>
        <td><code><b>mobileOpera</b></code></td>
        <td><code>Boolean</code></td>
        <td>如果是移动版的opera浏览器则返回 <code><span class="literal">true</span></code></td>
    </tr>
    <tr>
        <td><code><b>touch</b></code></td>
        <td><code>Boolean</code></td>
        <td>对于所有触摸设备上的浏览器返回 <code><span class="literal">true</span></code></td>
    </tr>
    <tr>
        <td><code><b>msTouch</b></code></td>
        <td><code>Boolean</code></td>
        <td>对于微软的触摸模式的浏览器（比如IE10）返回 <code><span class="literal">true</span></code></td>
    </tr>
    <tr>
        <td><code><b>retina</b></code></td>
        <td><code>Boolean</code></td>
        <td>如果是视网膜屏幕的设备则返回 <code><span class="literal">true</span></code></td>
    </tr>
</table>


<h2 id="util">L.Util</h2>

<p>Leaflet 内部使用的多种实用的函数。</p>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>extend</b>(
            <nobr>&lt;Object&gt; <i>dest</i></nobr>,
            <nobr>&lt;Object&gt; <i>src?..</i> )</nobr>
        </code></td>

        <td><code>Object</code></td>
        <td>将 <code>src</code> 对象（或多个对象）的属性合并到 <code>dest</code> 对象中并将其返回。具有一个 <code>L.extend</code> 的快捷方式。</td>
    </tr>
    <tr>
        <td><code><b>bind</b>(
            <nobr>&lt;Function&gt; <i>fn</i></nobr>,
            <nobr>&lt;Object&gt; <i>obj</i> )</nobr>
        </code></td>

        <td><code>Function</code></td>
        <td>返回由给定范围的obj执行 <code>fn</code> 函数的函数（所以关键字this可以表示函数代码里的obj）。具有一个 <code>L.bind</code> 快捷方式。</td>
    </tr>
    <tr>
        <td><code><b>stamp</b>( <nobr>&lt;Object&gt; <i>obj</i></nobr> )</code></td>
        <td><code>String</code></td>
        <td>在对象上应用一个主键并返回这个键。具有 <code>L.stamp</code> 快捷方式。</td>
    </tr>
    <!-- TODO Commented out for the time being:
    https://github.com/Leaflet/Leaflet/pull/793#discussion_r1134904
    <tr>
        <td><code><b>requestAnimFrame</b>()</code></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td><code><b>cancelAnimFrame</b>()</code></td>
        <td></td>
        <td></td>
    </tr>
    -->
    <tr>
        <td><code><b>limitExecByInterval</b>(
            <nobr>&lt;Function&gt; <i>fn</i></nobr>,
            <nobr>&lt;Number&gt; <i>time</i></nobr>,
            <nobr>&lt;Object&gt; <i>context?</i> )</nobr>
        </code></td>

        <td><code>Function</code></td>
        <td>返回调用尽量快的但不会比间隔时间还要频繁的fn函数的包装器（对于拖动地图时检验和请求信的切片比较有用），可以通过context选择函数调用的范围。</td>
    </tr>

    <tr>
        <td><code><b>falseFn</b>()</code></td>
        <td><code>Function</code></td>
        <td>返回总是返回 <code><span class="literal">false</span></code>的函数。</td>
    </tr>
    <tr>
        <td><code><b>formatNum</b>(
            <nobr>&lt;Number&gt; <i>num</i></nobr>,
            <nobr>&lt;Number&gt; <i>digits</i> )</nobr>
        </code></td>

        <td><code>Number</code></td>
        <td>返回 <code>digits</code> 位数的 <code>num</code> 的数目。</td>
    </tr>
    <tr>
        <td><code><b>splitWords</b>(
            <nobr>&lt;String&gt; <i>str</i> )</nobr>
        </code></td>

        <td><code>String[]</code></td>
        <td>根据空格和空白来截取分割字符串并返回数组。</td>
    </tr>
    <tr>
        <td><code><b>setOptions</b>(
            <nobr>&lt;Object&gt; <i>obj</i></nobr>,
            <nobr>&lt;Object&gt; <i>options</i> )</nobr>
        </code></td>

        <td><code>Object</code></td>
        <td>将所给的属性合并到obj的options中，返回最终的选项。</td>
    </tr>
    <tr>
        <td><code><b>getParamString</b>(
            <nobr>&lt;Object&gt; <i>obj</i> )</nobr>
        </code></td>

        <td><code>String</code></td>
        <td>将对象转换为带有参数的URL字符串，比如{a:"foo",b:"bar"}转换为'?a=foo&b=bar'。</td>
    </tr>
    <tr>
        <td><code><b>template</b>(
            <nobr>&lt;String&gt; <i>str</i>, &lt;Object&gt; <i>data</i> )</nobr>
        </code></td>

        <td><code>String</code></td>
        <td>是一个简单的模板，用通过将{a:'foo',b:'bar',...}形式的data对象应用到'Hello{a},{b}'形式的模板字符串来创建字符串——在上述示例中可以得到'Hello foo,bar'。</td>
    </tr>
    <tr>
        <td><code><b>isArray</b>(
            <nobr>&lt;Object&gt; <i>obj</i> )</nobr>
        </code></td>

        <td><code>Boolean</code></td>
        <td>如果对象为数组则返回 <code><span class="literal">true</span></code></td>
    </tr>
</table>

<h3>Properties（属性）</h3>

<table>
    <tr>
        <th>属性</th>
        <th>类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>emptyImageUrl</b></code></td>
        <td><code>String</code></td>
        <td>包含64位编码的空的GIF图像的数据URL字符串。在webkit驱动的移动设备的上，用来作为清空没用图像的存储的钩子。</td>
    </tr>
</table>



<h2 id="transformation">L.Transformation</h2>

<p>表示仿射变换：用一系列 <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> 的系数来将 <code>(x, y)</code> 形式转换为 <code>(a*x + b, c*y + d)</code> 的形式并进行反转。</p>

<pre><code>var transformation = new L.Transformation(2, 5, -1, 10),
    p = new L.Point(1, 2),
    p2 = transformation.transform(p), // new L.Point(7, 8)
    p3 = transformation.untransform(p2); // new L.Point(1, 2)
</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width250">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Transformation</b>(
            <nobr>&lt;Number&gt; <i>a</i></nobr>,
            <nobr>&lt;Number&gt; <i>b</i></nobr>,
            <nobr>&lt;Number&gt; <i>c</i></nobr>,
            <nobr>&lt;Number&gt; <i>d</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Transformation(<span class="comment">&hellip;</span>)</code><br />
            <!--<code>L.point(<span class="comment">&hellip;</span>)</code><br />
            <code>L.point([<span class="comment">&hellip;</span>])</code>-->
        </td>

        <td>通过给定的系数创建转换对象。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>transform</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>point</i></nobr>,
            <nobr>&lt;Number&gt; <i>scale?</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>返回转换后的点，可以选择扩大一定的倍数。只接受真实 <code>L.Point</code> 实例，而不是数组。</td>
    </tr>
    <tr>
        <td><code><b>untransform</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>point</i></nobr>,
            <nobr>&lt;Number&gt; <i>scale?</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>返回反转变换后的点，可以选择搜索一定倍数。只接受真实的 <code>L.Point</code> 实例，而不是数组。</td>
    </tr>
</table>




<h2 id="lineutil">L.LineUtil</h2>

<p>一些处理线段点的应用函数，在 Leaflet 内部用来使线段显示更快。</p>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>simplify</b>(
            <nobr>&lt;<a href="#point">Point</a>[]&gt; <i>points</i></nobr>,
            <nobr>&lt;Number&gt; <i>tolerance</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a>[]</code></td>

        <td>在保持形状的同时动态地减少线上点的数目并返回简化后点的数组。在每一缩放级别处理和显示 Leaflet 线段时可以大幅提升效率并可以减少视觉噪声。tolerance影像简化的量（较小的值意味着更高的质量，但效率会地因为有更多的点）。这也是微型类库Simplify.js中的一部分。</td>
    </tr>
    <tr>
        <td><code><b>pointToSegmentDistance</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>p</i></nobr>,
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>p1</i></nobr>,
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>p2</i> )</nobr>
        </code></td>

        <td><code>Number</code></td>

        <td>返回点p到p1和p2组成的线段之间的距离。</td>
    </tr>
    <tr>
        <td><code><b>closestPointOnSegment</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>p</i></nobr>,
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>p1</i></nobr>,
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>p2</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>

        <td>返回p1和p2线段上与p点最接近的点。</td>
    </tr>
    <tr>
        <td><code><b>clipSegment</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>a</i></nobr>,
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>b</i></nobr>,
            <nobr>&lt;<a href="#bounds">Bounds</a>&gt; <i>bounds</i> )</nobr>
        </code></td>

        <td><code>-</code></td>

        <td>用矩形边界裁剪点a到点b之间的折线段（直接修改折线段上的点）。在 Leaflet 中用来显示屏幕内或边缘的线段上的点，可以因此而提高效率。</td>
    </tr>
</table>



<h2 id="polyutil">L.PolyUtil</h2>

<p>多边形几何体的一些应用函数。</p>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>clipPolygon</b>(
            <nobr>&lt;<a href="#point">Point</a>[]&gt; <i>points</i></nobr>,
            <nobr>&lt;<a href="#bounds">Bounds</a>&gt; <i>bounds</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a>[]</code></td>

        <td>通过矩形边界来裁剪给定点定义的多边形几何体。在 Leaflet 中用来显示屏幕内或边缘的线段上的多边形上的点，可以因此而提高效率。多边形点需要不同的算法来裁剪折线段，因此这个方法也有不同的分支。</td>
    </tr>
</table>




<h2 id="domevent">L.DomEvent</h2>

<p>Leaflet 内部用来处理DOM事件的应用函数。</p>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>addListener</b>(
            <nobr>&lt;HTMLElement&gt; <i>el</i></nobr>,
            <nobr>&lt;String&gt; <i>type</i></nobr>,
            <nobr>&lt;Function&gt; <i>fn</i></nobr>,
            <nobr>&lt;Object&gt; <i>context?</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>向指定类型的DOM事件元素添加监听器fn。监听器中的this关键字指向context，或是在没有说明的情况下指向要素。</td>
    </tr>
    <tr>
        <td><code><b>removeListener</b>(
            <nobr>&lt;HTMLElement&gt; <i>el</i></nobr>,
            <nobr>&lt;String&gt; <i>type</i></nobr>,
            <nobr>&lt;Function&gt; <i>fn</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>在元素中移除事件监听器。</td>
    </tr>
    <tr>
        <td><code><b>stopPropagation</b>(
            <nobr>&lt;DOMEvent&gt; <i>e</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>停止事件向父元素传播。:
<pre><code>L.DomEvent.addListener(div, 'click', function (e) {
    L.DomEvent.stopPropagation(e);
    });</code></pre>
        </td>
    </tr>
    <tr>
        <td><code><b>preventDefault</b>(
            <nobr>&lt;DOMEvent&gt; <i>e</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>阻止事件默认的动作发生（比如追踪元素href中的链接，或是当form提交时页面重载的POST请求）。</pre>
        </td>
    </tr>
    <tr>
        <td><code><b>stop</b>(
            <nobr>&lt;DOMEvent&gt; <i>e</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>在同一时刻发起stopPropagation和preventDefault。</td>
    </tr>
    <tr>
        <td><code><b>disableClickPropagation</b>(
            <nobr>&lt;HTMLElement&gt; <i>el</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>将stopPropagation添加到元素的'click','doubleclick','mousedown'和'touchstart'事件中。</td>
    </tr>
    <tr>
        <td><code><b>getMousePosition</b>(
            <nobr>&lt;DOMEvent&gt; <i>e</i></nobr>,
            <nobr>&lt;HTMLElement&gt; <i>container?</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>如果没有特意说明则获取与容器或整个页面相关的DOM事件的标准的鼠标位置。</td>
    </tr>
    <tr>
        <td><code><b>getWheelDelta</b>(
            <nobr>&lt;DOMEvent&gt; <i>e</i> )</nobr>
        </code></td>

        <td><code>Number</code></td>
        <td>从mousewheel的DOM事件中获取标准的滚轮区域。</td>
    </tr>
</table>




<h2 id="domutil">L.DomUtil</h2>

<p>Leaflet 内部用来处理DOM树的应用函数。</p>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>get</b>(
            <nobr>&lt;String or HTMLElement&gt; <i>id</i> )</nobr>
        </code></td>

        <td><code>HTMLElement</code></td>
        <td>如果传递字符串则返回一个带有指定id的元素，或是只是返回这个元素。</td>
    </tr>
    <tr>
        <td><code><b>getStyle</b>(
            <nobr>&lt;HTMLElement&gt; <i>el</i></nobr>,
            <nobr>&lt;String&gt; <i>style</i> )</nobr>
        </code></td>

        <td><code>String</code></td>
        <td>返回元素中特定样式属性的值，包括计算后的值和CSS中设置的值。</td>
    </tr>
    <tr>
        <td><code><b>getViewportOffset</b>(
            <nobr>&lt;HTMLElement&gt; <i>el</i> )</nobr>
        </code></td>

        <td><a href="#point"><code>Point</code></a></td>
        <td>返回请求元素视图的偏移量。</td>
    </tr>
    <tr>
        <td><code><b>create</b>(
            <nobr>&lt;String&gt; <i>tagName</i></nobr>,
            <nobr>&lt;String&gt; <i>className</i></nobr>,
            <nobr>&lt;HTMLElement&gt; <i>container?</i> )</nobr>
        </code></td>

        <td><code>HTMLElement</code></td>

        <td>通过tagName创建元素，设置className并选择性地将其附加到container元素中。</td>
    </tr>
    <tr>
        <td><code><b>disableTextSelection</b>()</code></td>
        <td>-</td>
        <td>使文本不能被选择，比如拖动的时候。</td>
    </tr>
    <tr>
        <td><code><b>enableTextSelection</b>()</code></td>
        <td>-</td>
        <td>使文本选择重新可用。</td>
    </tr>
    <tr>
        <td><code><b>hasClass</b>(
            <nobr>&lt;HTMLElement&gt; <i>el</i></nobr>,
            <nobr>&lt;String&gt; <i>name</i> )</nobr>
        </code></td>

        <td><code>Boolean</code></td>

        <td>如果元素类属性包含name则返回 <code><span class="literal">true</span></code></td>
    </tr>
    <tr>
        <td><code><b>addClass</b>(
            <nobr>&lt;HTMLElement&gt; <i>el</i></nobr>,
            <nobr>&lt;String&gt; <i>name</i> )</nobr>
        </code></td>

        <td>-</td>

        <td>将name添加到元素类的属性中。</td>
    </tr>
    <tr>
        <td><code><b>removeClass</b>(
            <nobr>&lt;HTMLElement&gt; <i>el</i></nobr>,
            <nobr>&lt;String&gt; <i>name</i> )</nobr>
        </code></td>

        <td>-</td>

        <td>在元素类属性中移除name。</td>
    </tr>
    <tr>
        <td><code><b>setOpacity</b>(
            <nobr>&lt;HTMLElement&gt; <i>el</i></nobr>,
            <nobr>&lt;Number&gt; <i>value</i> )</nobr>
        </code></td>

        <td>-</td>
        <td>设置元素的透明度（包括老的IE也支持）。值应当处于0到1之间。</td>
    </tr>
    <tr>
        <td><code><b>testProp</b>(
            <nobr>&lt;String[]&gt; <i>props</i> )</nobr>
        </code></td>

        <td><code>String</code> or <code><span class="literal">false</span></code></td>
        <td>检索样式名称的数组并返回第一个元素可用样式的名称。如果没有找到，那么返回false。</td>
    </tr>
    <tr>
        <td><code><b>getTranslateString</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>point</i> )</nobr>
        </code></td>

        <td><code>String</code></td>
        <td>返回CSS转换字符串来通过给定点提供的偏移量来移动元素。</td>
    </tr>
    <tr>
        <td><code><b>getScaleString</b>(
            <nobr>&lt;Number&gt; <i>scale</i></nobr>,
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>origin</i> )</nobr>
        </code></td>

        <td><code>String</code></td>
        <td>返回CSS转换字符串来缩放元素（通过给定的比例原点）。</td>
    </tr>
    <tr>
        <td><code><b>setPosition</b>(
            <nobr>&lt;HTMLElement&gt; <i>el</i></nobr>,
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>point</i></nobr>,
            <nobr>&lt;Boolean&gt; <i>disable3D?</i> )</nobr>
        </code></td>

        <td>-</td>
        <td>用CSS转换或屏幕左上角位置设置给定点的坐标系下的元素位置（Leaflet 内在地定位图层）。如果disable3D设置为true那么强制为左上角位置。</td>
    </tr>
    <tr>
        <td><code><b>getPosition</b>(
            <nobr>&lt;HTMLElement&gt; <i>el</i> )</nobr>
        </code></td>

        <td><a href="#point">Point</a></td>
        <td>返回之前用setPosition定位的元素的坐标。</td>
    </tr>
</table>

<h3>Properties（属性）</h3>

<table>
    <tr>
        <th>属性</th>
        <th>类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>TRANSITION</b></nobr>
        </code></td>
        <td><code>String</code></td>
        <td>带前缀的转换样式名称（如 <code><span class="string">'webkitTransition'</span></code> 用来表示WebKit）。</td>
    </tr>
    <tr>
        <td><code><b>TRANSFORM</b></nobr>
        </code></td>
        <td><code>String</code></td>
        <td>带前缀的变换样式名称。</td>
    </tr>
</table>



<h2 id="posanimation">L.PosAnimation</h2>

<p>在内部用来平移动画镜头，利用CSS3转换在现代浏览器中实现，在IE6到9中用时间降速的功能实现。</p>

<pre><code class="javascript">var fx = new L.PosAnimation();
    fx.run(el, [300, 500], 0.5);</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width200">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.PosAnimation</b>()</code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.PosAnimation()</code>
        </td>

        <td>创建动画对象。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>run</b>(
            <nobr>&lt;HTMLElement&gt; <i>element</i>,</nobr>
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>newPos</i></nobr>,
            <nobr>&lt;Number&gt; <i>duration?</i></nobr>,
            <nobr>&lt;Number&gt; <i>easeLinearity?</i> )</nobr>
        </code></td>

        <td><code><span class="keyword">this</span></code></td>
        <td>在新的位置运行指定元素，可以选择性地设置持续的秒数（默认是0.25秒）和线性效果（通过cubic bezier curve的第三个参数，默认是0.5）。</td>
    </tr>
</table>

<h3>Events（事件）</h3>

<p>You can subscribe to the following events using <a href="#events">these methods</a>.</p>

<table>
    <tr>
        <th class="width100">事件</th>
        <th class="width100">Data</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>start</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>当动画开始时触发。</td>
    </tr>
    <tr>
        <td><code><b>step</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>在动画过程中持续触发。</td>
    </tr>
    <tr>
        <td><code><b>end</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>动画结束时触发。</td>
    </tr>
</table>



<h2 id="draggable">L.Draggable</h2>

<p>使DOM元素可以拖动的类。在内部被用来拖动地图和注记。</p>

<pre><code class="javascript">var draggable = new L.Draggable(elementToDrag);
    draggable.enable();
</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th class="width200">构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Draggable</b>(
            <nobr>&lt;HTMLElement&gt; <i>element</i>,</nobr>
            <nobr>&lt;HTMLElement&gt; <i>dragHandle?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Draggable(<span class="comment">&hellip;</span>)</code><!--<br />
            <code>L.draggable(<span class="comment">&hellip;</span>)</code>-->
        </td>

        <td>创建可拖动对象，这样在你开始移动dragHandle元素时就可以移动给定元素了（默认同元素自身是同一个）。</td>
    </tr>
</table>

<h3>Events（事件）</h3>

<table>
    <tr>
        <th class="width100">事件</th>
        <th class="width100">Data</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>dragstart</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>拖动开始时触发。</td>
    </tr>
    <tr>
        <td><code><b>predrag</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>在拖动过程中相应元素位置更新之前持续触发。</td>
    </tr>
    <tr>
        <td><code><b>drag</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>拖动过程中持续触发。</td>
    </tr>
    <tr>
        <td><code><b>dragend</b></code></td>
        <td><code><a href="#event">Event</a></code></td>
        <td>拖动结束后触发。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th class="width100">方法</th>
        <th class="width100">返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>enable</b>()</code></td>
        <td><code>-</code></td>
        <td>使拖动功能可用。</td>
    </tr>
    <tr>
        <td><code><b>disable</b>()</code></td>
        <td><code>-</code></td>
        <td>使拖动功能不可用。</td>
    </tr>
</table>

<!--<h3>Static Properties</h3>

<table>
    <tr>
        <th>属性</th>
        <th>类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>START</b></code></td>
        <td><code>String</code></td>
        <td>Name of the DOM event that initiates dragging. <code><span class="string">'mousedown'</span></code> for desktop browsers, <code><span class="string">'touchstart'</span></code> for mobile devices.</td>
    </tr>
    <tr>
        <td><code><b>MOVE</b></code></td>
        <td><code>String</code></td>
        <td>Name of the DOM event for drag moving. <code><span class="string">'mousemove'</span></code> for desktop browsers, <code><span class="string">'touchmove'</span></code> for mobile devices.</td>
    </tr>
    <tr>
        <td><code><b>END</b></code></td>
        <td><code>String</code></td>
        <td>Name of the DOM event that ends dragging. <code><span class="string">'mouseup'</span></code> for desktop browsers, <code><span class="string">'touchend'</span></code> for mobile devices.</td>
    </tr>
</table>-->



<h2 id="bussearch">L.BusSearch</h2>

<p>公交查询 服务接口</p>

<pre><code class="javascript">var busSearch = new L.BusSearch();
    busSearch.byTwoPoi({start:[39.2,116.8],stop:[39.3,116.7]},function(data){
        console.log(data);
    });
</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th>构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.BusSearch</b>(<nobr>&lt;<a href="#bussearch-options">BusSearch options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.BusSearch(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>根据给定的参数构造一个L.BusSearch公交查询类的新实例。</td>
    </tr>
</table>

<h3 id="bussearch-options">Options（选项）</h3>

<h4>BusSearch Options（构造选项）</h4>

<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>encode </b></code></td>
        <td><code>String</code></td>
        <td><code><span class="literal">null</span></code></td>
        <td>字符编码，不区分大小写，默认值为UTF-8编码。</td>
    </tr>
    <tr>
        <td><code><b>page</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="literal">1</span></code></td>
        <td>请求页面,默认为第1页。</td>
    </tr>
    <tr>
        <td><code><b>pageSize</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="literal">10</span></code></td>
        <td>每页记录数，默认为每页显示10条记录。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th class="width300">方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>byTwoPoi</b>(
            <nobr>&lt;{start:<a href="#latlng">latlng</a> <i>latlng</i> ,stop:<a href="#latlng">latlng</a> <i>latlng</i> }&gt; <i>object</i> ,</nobr>
            <nobr>&lt;<a href="#string">city</a>&gt; <i>string</i> ,</nobr>
            <nobr>&lt;<a href="#function">callback_func</a>&gt; <i>function</i> )</nobr>
        </code></td>

        <td><code><a href="#bussearch-json">Json</a></code></td>
        <td>公交换乘基于 起点 终点 坐标集合。</td>
    </tr>
    <tr>
        <td><code><b>byBusStation</b>(
            <nobr>&lt;<a href="#string">stationName</a>&gt; <i>string</i> ,</nobr>
            <nobr>&lt;<a href="#string">city</a>&gt; <i>string</i> ,</nobr>
            <nobr>&lt;<a href="#bussearch-function">callback_func</a>&gt; <i>function</i> )</nobr>
        </code></td>

        <td><code><a href="#bussearch-json">Json</a></code></td>
        <td>根据站点名称查询经过该站点的所有公交线路信息。</td>
    </tr>
</table>

<h3 id="bussearch-json">Return Data（返回数据格式）</h3>

<table>
    <tr>
        <td colspan="2">bounds</td>
        <td colspan="4">坐标范围，矩形西南、东北角坐标</td>
    </tr>
    <tr>
        <td width="51" rowspan="12">busList</td>
        <td width="109" rowspan="12">换乘方案列表</td>
        <td colspan="2">bounds</td>
        <td colspan="2">坐标范围，矩形西南、东北角坐标</td>
    </tr>
    <tr>
        <td colspan="2">footEndLength</td>
        <td colspan="2">换乘方案结束后，步行到终点距离</td>
    </tr>
    <tr>
        <td width="83" rowspan="9">segmentList</td>
        <td width="92" rowspan="9">路段列表</td>
        <td width="115"> busName</td>
        <td width="214">路线名称</td>
    </tr>
    <tr>
        <td>startName</td>
        <td>起点名称</td>
    </tr>
    <tr>
        <td>driverLength</td>
        <td class="javascript">行驶距离，单位：米</td>
    </tr>
    <tr>
        <td>footLength</td>
        <td>步行距离，单位：米</td>
    </tr>
    <tr>
        <td>passDepotCoordinate</td>
        <td>途经站点名称</td>
    </tr>
    <tr>
        <td>coordinateList</td>
        <td>途经站点坐标</td>
    </tr>
    <tr>
        <td>passDepotName</td>
        <td>步行经过点坐标</td>
    </tr>
    <tr>
        <td>endName</td>
        <td>终点名称</td>
    </tr>
    <tr>
        <td>passDepotCount</td>
        <td>途经站点数量</td>
    </tr>
    <tr>
        <td colspan="2">cache</td>
        <td colspan="2">是否缓存</td>
    </tr>
    <tr>
        <td colspan="2">count</td>
        <td colspan="4">换乘方案数</td>
    </tr>
    <tr>
        <td colspan="2">message</td>
        <td colspan="4">ok</td>
    </tr>
    <tr>
        <td colspan="2">searchtime</td>
        <td colspan="4">耗时 毫秒 </td>
    </tr>
</table>

<h2 id="dailynews">L.DailyNews</h2>

<p>热点聚焦新闻 服务接口</p>

<pre><code class="javascript">var dailynews = new L.DailyNews({type:2});
    dailynews.byDefault(function(data){
    console.log(data);
    });
</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th>构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.DailyNews</b>(<nobr>&lt;<a href="#dailynews-options">DailyNews options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.DailyNews(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>根据给定的参数构造一个L.DailyNews热点聚焦新闻查询类的新实例。</td>
    </tr>
</table>

<h3 id="dailynews-options">Options（选项）</h3>

<h4>DailyNews Options（构造选项）</h4>

<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>type</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="literal">null</span></code></td>
        <td>栏目</td>
    </tr>
    <tr>
        <td><code><b>page</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="literal">1</span></code></td>
        <td>请求页面,默认为第1页。</td>
    </tr>
    <tr>
        <td><code><b>pageSize</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="literal">10</span></code></td>
        <td>每页记录数，默认为每页显示10条记录。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th class="width300">方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>byDefault</b>(<nobr>&lt;<a href="#function">callback_func</a>&gt; <i>function</i> )</nobr>
        </code></td>

        <td><code><a href="#dailynews-json">Json</a></code></td>
        <td>默认查询最新的资讯</td>
    </tr>
</table>

<h3 id="dailynews-json">Return Data（返回数据格式）</h3>

<h2 id="partition">L.Partition</h2>

<p>行政区域查询 服务接口</p>

<pre><code class="javascript">var partition = new L.Partition({type:2});
    partition.byLatLng([39,116],5,function(data){
    console.log(data);
    });
</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th>构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Partition</b>()
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Partition()</code>
        </td>

        <td>根据给定的参数构造一个L.Partition 行政区域查询类的新实例。</td>
    </tr>
</table>



<h3>Methods（方法）</h3>

<table>
    <tr>
        <th class="width300">方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>byLatLng</b>(<nobr>&lt;<a href="#latlng">latlng</a>&gt;  <i>latlng</i>,</nobr>
            <nobr>&lt;<a href="#number">zoom</a>&gt;  <i>number</i>,</nobr>
            <nobr>&lt;<a href="#function">callback_func</a>&gt; <i>function</i> )</nobr>
        </code></td>

        <td><code><a href="#partition-json">Json</a></code></td>
        <td>通过坐标 缩放等级 查询 父级市县和下级市县</td>
    </tr>
</table>

<h3 id="partition-json">Return Data（返回数据格式）</h3>


<h2 id="poisearch">L.Poisearch</h2>

<p>地点查询 服务接口</p>

<pre><code class="javascript">var poisearch = new L.Poisearch({type:2});
    poisearch.byLatLng([39,116],5,function(data){
    console.log(data);
    });
</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th>构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Poisearch</b>()
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Poisearch()</code>
        </td>

        <td>根据给定的参数构造一个L.Poisearch 查询类的新实例。</td>
    </tr>
</table>



<h3>Methods（方法）</h3>

<table>
    <tr>
        <th class="width300">方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>byRegion</b>(<nobr>&lt;<a href="#latlng">latlng</a>[]&gt;  <i>latlngs</i>,</nobr>
            <nobr>&lt;<a href="#string">keyWord</a>&gt;  <i>String</i>,</nobr>
            <nobr>&lt;<a href="#function">callback_func</a>&gt; <i>function</i> )</nobr>
        </code></td>
        <td><code><a href="#poisearch-json">Json</a></code></td>
        <td>坐标范围内 关键字 搜索位置信息</td>
    </tr>
    <tr>
        <td><code><b>byZoomLatLng</b>(<nobr>&lt;<a href="#number">zoom</a>&gt;  <i>number</i>,</nobr>
            <nobr>&lt;<a href="#latlng">latlng</a>&gt;  <i>latlng</i>,</nobr>
            <nobr>&lt;<a href="#function">callback_func</a>&gt; <i>function</i> )</nobr>
        </code></td>
        <td><code><a href="#poisearch-json">Json</a></code></td>
        <td>通过缩放等级和坐标查询位置信息</td>
    </tr>
</table>

<h3 id="poisearch-json">Return Data（返回数据格式）</h3>


<h2 id="routesearch">L.RouteSearch</h2>

<p>驾车路线查询 服务接口</p>

<pre><code class="javascript">var routeSearch = new L.RouteSearch();
    routeSearch.getNaviPath({start:[39.2,116.8],stop:[39.3,116.7]},function(data){
    console.log(data);
    });
</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th>构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.RouteSearch</b>(<nobr>&lt;<a href="#routesearch-options">RouteSearch options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.RouteSearch(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>根据给定的参数构造一个L.Thematic 专题图查询类的新实例。</td>
    </tr>
</table>

<h3 id="routesearch-options">Options（选项）</h3>

<h4>RouteSearch Options（构造选项）</h4>

<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>routeType</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="literal">0</span></code></td>
        <td>0速度优先 1费用优先 2距离优先 5不走快速路（包括高速） 6国道优先 7省道优先 8不走高速 9多策略</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th class="width300">方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>getNaviPath</b>(<nobr>&lt;{start:<a href="#latlng">latlng</a> <i>latlng</i> ,stop:<a href="#latlng">latlng</a> <i>latlng</i> }&gt; <i>object</i> ,</nobr>
            <nobr>&lt;<a href="#function">callback_func</a>&gt; <i>function</i> )</nobr>
        </code></td>

        <td><code><a href="#routesearch-json">Json</a></code></td>
        <td>通过 导航坐标数组 查询驾车路线</td>
    </tr>
</table>

<h3 id="routesearch-json">Return Data（返回数据格式）</h3>

<table>
    <tr>
        <td width="63">bounds</td>
        <td colspan="3">导航起始点范围</td>
    </tr>
    <tr>
        <td>searchtime</td>
        <td colspan="3">查询时长</td>
    </tr>
    <tr>
        <td>coors</td>
        <td colspan="3">行驶路线坐标</td>
    </tr>
    <tr>
        <td>cache</td>
        <td colspan="3">是否缓存</td>
    </tr>
    <tr>
        <td>count</td>
        <td colspan="3">导航路径的段数</td>
    </tr>
    <tr>
        <td>message</td>
        <td colspan="3">错误代码，ok表示成功</td>
    </tr>

    <tr>
        <td rowspan="10">segmengList</td>
        <td width="128" rowspan="10">路段导航信息列表</td>
        <td width="186">form</td>
        <td width="187">道路性质描述</td>
    </tr>
    <tr>
        <td>coor</td>
        <td>行驶路段坐标</td>
    </tr>
    <tr>
        <td>direction</td>
        <td>行驶方向</td>
    </tr>
    <tr>
        <td>roadLength</td>
        <td>行驶距离</td>
    </tr>
    <tr>
        <td>action</td>
        <td>辅助动作</td>
    </tr>
    <tr>
        <td>grade</td>
        <td>道路等级</td>
    </tr>
    <tr>
        <td>textInfo</td>
        <td>此段道路行使文字描述</td>
    </tr>
    <tr>
        <td>accessorialInfo</td>
        <td>动作</td>
    </tr>
    <tr>
        <td>roadName</td>
        <td>道路名称</td>
    </tr>
    <tr>
        <td>driveTime</td>
        <td>行驶时间</td>
    </tr>
</table>

<h2 id="thematic">L.Thematic</h2>

<p>专题图 服务接口</p>

<pre><code class="javascript">var thematic = new L.Thematic();
    thematic.byDefault(function(data){
    console.log(data);
    });
</code></pre>

<h3>Constructor（函数构造器）</h3>

<table>
    <tr>
        <th>构造函数</th>
        <th>用法</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Thematic</b>(<nobr>&lt;<a href="#thematic-options">Thematic options</a>&gt; <i>options?</i> )</nobr>
        </code></td>

        <td class="factory-usage">
            <code><span class='keyword'>new</span> L.Thematic(<span class="comment">&hellip;</span>)</code>
        </td>

        <td>根据给定的参数构造一个L.Thematic 专题图查询类的新实例。</td>
    </tr>
</table>

<h3 id="thematic-options">Options（选项）</h3>

<h4>Thematic Options（构造选项）</h4>

<table>
    <tr>
        <th>参数</th>
        <th>类型</th>
        <th>默认值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>page</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="literal">1</span></code></td>
        <td>请求页面,默认为第1页。</td>
    </tr>
    <tr>
        <td><code><b>pageSize</b></code></td>
        <td><code>Number</code></td>
        <td><code><span class="literal">10</span></code></td>
        <td>每页记录数，默认为每页显示10条记录。</td>
    </tr>
</table>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th class="width300">方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>byDefault</b>(<nobr>&lt;<a href="#function">callback_func</a>&gt; <i>function</i> )</nobr>
        </code></td>

        <td><code><a href="#thematic-json">Json</a></code></td>
        <td>默认查询最新专题图列表</td>
    </tr>
    <tr>
        <td><code><b>byKeyWord</b>(<nobr>&lt;<a href="#string">keyWord</a>&gt; <i>String</i> ,</nobr>
            <nobr>&lt;<a href="#function">callback_func</a>&gt; <i>function</i> )</nobr>
        </code></td>

        <td><code><a href="#thematic-json">Json</a></code></td>
        <td>通过 关键字 查询专题图列表</td>
    </tr>
</table>

<h3 id="thematic-json">Return Data（返回数据格式）</h3>


<h2 id="ihandler">IHandler</h2>
<p>继承自 <a href="#map-interaction-handlers">interaction handlers</a>接口。</p>

<table>
    <tr>
        <th class="width100">方法</th>
        <th class="width100">返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>enable</b>()</code></td>
        <td>-</td>
        <td>使处理程序可用。</td>
    </tr>
    <tr>
        <td><code><b>disable</b>()</code></td>
        <td>-</td>
        <td>使处理程序不可用。</td>
    </tr>
    <tr>
        <td><code><b>enabled</b>()</code></td>
        <td><code>Boolean</code></td>
        <td>如果处理程序可用则返回 <code><span class="literal">true</span></code>。</td>
    </tr>
</table>


<h2 id="ilayer">ILayer</h2>

<p>显示地图上附属于某一位置（或一系列位置）的对象。被 <a href="#tilelayer">tile layers</a>, <a href="#marker">markers</a>, <a href="#popup">popups</a>, <a href="#imageoverlay">image overlays</a>, <a href="#path">vector layers</a> and <a href="#layergroup">layer groups</a>所继承。</p>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>onAdd</b>(
            <nobr>&lt;<a href="#map">Map</a>&gt; <i>map</i> )</nobr>
        </code></td>

        <td>-</td>
        <td>需要包含创建覆盖物的DOM元素的代码，将他们加入到所属的 <a href="#map-panes">map panes</a> 中并在相关地图时间中放入监听器。调用 <code>map.addLayer(layer)</code>.</td>
    </tr>
    <tr>
        <td><code><b>onRemove</b>(
            <nobr>&lt;<a href="#map">Map</a>&gt; <i>map</i> )</nobr>
        </code></td>

        <td>-</td>
        <td>包含从DOM移除覆盖物元素和移除之前 <code>onAdd</code>方法添加的监听器的所有的清除代码。调用 <code>map.removeLayer(layer)</code>.</td>
    </tr>
</table>

<h3>Implementing Custom Layers（实例化自定义图层）</h3>

<p>何时实例化自定义图层最重要的是地图的 <a href="#map-viewreset">viewreset</a> 事件和 <a href="#map-latlngtolayerpoint">latLngToLayerPoint</a> 方法。<code>viewreset</code> 在地图需要重新定位图层时（比如缩放时）触发， <code>latLngToLayerPoint</code> 在获取图层新的位置时使用。</p>

<p>在实例化图层时还有一个经常用到的事件是 <a href="#map-moveend">moveend</a> ，在地图移动之后触发（比如平移和缩放等）。</p>

<p>还有一个需要注意的事情是你需要经常向你在图层中创建的DOM元素中添加 <code>ocean-zoom-hide</code> 类，它会在缩放动画中隐藏。实例化自定义图层的缩放动画师一个复杂的话题，在以后的章节中会讲到，但你可以在 Leaflet 的图层代码（比如 <code>ImageOverlay</code>)中看一下它是如何工作的。</p>

<h3>自定义图层示例</h3>

<p>Here's how a custom layer implementation usually looks:</p>

<pre><code>var MyCustomLayer = L.Class.extend({

    initialize: function (latlng) {
    // save position of the layer or any options from the constructor
    this._latlng = latlng;
    },

    onAdd: function (map) {
    this._map = map;

    // create a DOM element and put it into one of the map panes
    this._el = L.DomUtil.create('div', 'my-custom-layer ocean-zoom-hide');
    map.getPanes().overlayPane.appendChild(this._el);

    // add a viewreset event listener for updating layer's position, do the latter
    map.on('viewreset', this._reset, this);
    this._reset();
    },

    onRemove: function (map) {
    // remove layer's DOM elements and listeners
    map.getPanes().overlayPane.removeChild(this._el);
    map.off('viewreset', this._reset, this);
    },

    _reset: function () {
    // update layer's position
    var pos = this._map.latLngToLayerPoint(this._latlng);
    L.DomUtil.setPosition(this._el, pos);
    }
    });

    map.addLayer(new MyCustomLayer(latlng));
</code></pre>



<h2 id="icontrol">IControl</h2>

<p>在地图的某个角上显示UI元素。被 <a href="#control-zoom">zoom</a>, <a href="#control-attribution">attribution</a>, <a href="#control-scale">scale</a> , <a href="#control-layers">layers</a> 所继承。</p>

<h3>Methods（方法）</h3>

<p>Every control in Leaflet should extend from <a href="#control">Control</a> class and additionally have the following methods:</p>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>onAdd</b>(
            <nobr>&lt;<a href="#map">Map</a>&gt; <i>map</i> )</nobr>
        </code></td>

        <td><code>HTMLElement</code></td>
        <td>包含所有用于在相关地图事件上控制、添加监听器的创建必要DOM要素的代码，并返回包含控制的元素。调用 <code>map.addControl(control)</code> 或 <code>control.addTo(map)</code>.</td>
    </tr>
    <tr>
        <td><code><b>onRemove</b>(
            <nobr>&lt;<a href="#map">Map</a>&gt; <i>map</i> )</nobr>
        </code></td>

        <td>-</td>
        <td>包含所有清除代码（比如0移除控制事件监听器）。调用 <code>map.removeControl(control)</code> 或 <code>control.removeFrom(map)</code>。控制的DOM容器自动移除。</td>
    </tr>
</table>

<h3>Custom Control Example</h3>

<pre><code>var MyControl = L.Control.extend({
    options: {
    position: 'topright'
    },

    onAdd: function (map) {
    // create the control container with a particular class name
    var container = L.DomUtil.create('div', 'my-custom-control');

    // ... initialize other DOM elements, add listeners, etc.

    return container;
    }
    });

    map.addControl(new MyControl());
</code></pre>

<p>If specify your own constructor for the control, you'll also probably want to process options properly:</p>

<pre><code>var MyControl = L.Control.extend({
    initialize: function (foo, options) {
    // ...
    L.Util.setOptions(this, options);
    },
    // ...
    });</code></pre>

<p>This will allow you to pass options like <code>position</code> when creating the control instances:</p>

<pre><code>map.addControl(new MyControl('bar', {position: 'bottomleft'}));</code></pre>




<h2 id="iprojection">IProjection</h2>

<p>具有将地理坐标投影到平面（和后方）的方法的对象。参阅 <a href="http://en.wikipedia.org/wiki/Map_projection">Map projection</a>.</p>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>project</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>将地理坐标投影为二维点。</td>
    </tr>
    <tr>
        <td><code><b>unproject</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>point</i> )</nobr>
        </code></td>

        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>将二维的点反投影为地理位置。</td>
    </tr>
</table>

<h3>Defined Projections（定义的投影）</h3>

<p>Leaflet comes with a set of already defined projections out of the box:</p>

<table>
    <tr>
        <th>Projection</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.Projection.SphericalMercator</b></code></td>

        <td>Spherical Mercator projection &mdash; the most common projection for online maps, used by almost all free and commercial tile providers. Assumes that Earth is a sphere. Used by the <code>EPSG:3857</code> CRS.</td>
    </tr>
    <tr>
        <td><code><b>L.Projection.Mercator</b></code></td>

        <td>Elliptical Mercator projection &mdash; more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the <code>EPSG:3395</code> CRS.</td>
    </tr>
    <tr>
        <td><code><b>L.Projection.LonLat</b></code></td>

        <td>Equirectangular, or Plate Carree projection &mdash; the most simple projection, mostly used by GIS enthusiasts. Directly maps <code>x</code> as longitude, and <code>y</code> as latitude. Also suitable for flat worlds, e.g. game maps. Used by the <code>EPSG:3395</code> and <code>Simple</code> CRS.</td>
    </tr>
</table>




<h2 id="icrs">ICRS</h2>

<p>为将地理点投影到像素坐标或屏幕坐标和反向投影（投影到用于WMS服务的其他单位的坐标）而定义坐标参考系统。参阅 <a href="http://en.wikipedia.org/wiki/Coordinate_reference_system">Spatial reference system</a>.</p>

<h3>Methods（方法）</h3>

<table>
    <tr>
        <th>方法</th>
        <th>返回值</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>latLngToPoint</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i></nobr>,
            <nobr>&lt;Number&gt; <i>zoom</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>将给定缩放级别的地理坐标投影为像素坐标。</td>
    </tr>
    <tr>
        <td><code><b>pointToLatLng</b>(
            <nobr>&lt;<a href="#point">Point</a>&gt; <i>point</i></nobr>,
            <nobr>&lt;Number&gt; <i>zoom</i> )</nobr>
        </code></td>

        <td><code><a href="#latlng">LatLng</a></code></td>
        <td>是 <code>latLngToPoint</code>的反转。将给定缩放级别的像素坐标投影为地理坐标。</td>
    </tr>
    <tr>
        <td><code><b>project</b>(
            <nobr>&lt;<a href="#latlng">LatLng</a>&gt; <i>latlng</i> )</nobr>
        </code></td>

        <td><code><a href="#point">Point</a></code></td>
        <td>将地理坐标投影为CRS可接受单位的坐标（比如 <code>EPSG:3857</code>中的米，传递给WMS服务）。</td>
    </tr>
    <tr>
        <td><code><b>scale</b>(
            <nobr>&lt;Number&gt; <i>zoom</i> )</nobr>
        </code></td>

        <td><code>Number</code></td>
        <td>返回转换投影坐标为特定级别的像素坐标所用到的缩放级别。比如，在基于墨卡托投影的CRS中返回<code>256 * 2^zoom</code> 。</td>
    </tr>
</table>

<h3>Properties（属性）</h3>

<table>
    <tr>
        <th>属性</th>
        <th>类型</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>projection</b></code></td>

        <td><code><a href="#iprojection">IProjection</a></code></td>
        <td>CRS使用的投影。</td>
    </tr>
    <tr>
        <td><code><b>transformation</b></code></td>

        <td><code><a href="#transformation">Transformation</a></code></td>
        <td>CRS使用的用来将投影坐标转换为特定切片服务的屏幕坐标的转换方式。</td>
    </tr>

    <tr>
        <td><code><b>code</b></code></td>

        <td><code>String</code></td>
        <td>向WMS服务传递的标准CRS的标准代码名称（比如 <code><span class="string">'EPSG:3857'</span></code>).</td>
    </tr>
</table>

<h3>Defined CRS（定义的坐标参考系统）</h3>

<p>Leaflet comes with a set of already defined CRS to use out of the box:</p>

<table>
    <tr>
        <th>Projection</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L.CRS.EPSG3857</b></code></td>

        <td>The most common CRS for online maps, used by almost all free and commercial tile providers. Uses Spherical Mercator projection. Set in by default in Map's <code>crs</code> option.</td>
    </tr>
    <tr>
        <td><code><b>L.CRS.EPSG4326</b></code></td>

        <td>A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.</td>
    </tr>
    <tr>
        <td><code><b>L.CRS.EPSG3395</b></code></td>

        <td>Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.</td>
    </tr>
    <tr>
        <td><code><b>L.CRS.Simple</b></code></td>

        <td>A simple CRS that maps longitude and latitude into <code>x</code> and <code>y</code> directly. May be used for maps of flat surfaces (e.g. game maps). Note that the <code>y</code> axis should still be inverted (going from bottom to top).</td>
    </tr>
</table>

<p>If you want to use some obscure CRS not listed here, take a look at the <a href="https://github.com/kartena/Proj4Leaflet">Proj4Leaflet</a> plugin.</p>


<h2 id="global">Global Switches</h2>

<p>Global switches are created for rare cases and generally make Leaflet to not detect a particular browser feature even if it's there. You need to set the switch as a global variable to <code><span class="literal">true</span></code> <em>before</em> including Leaflet on the page, like this:</p>

<pre><code>&lt;script&gt;L_PREFER_CANVAS = true;&lt;/script&gt;
    &lt;script src="ocean.js"&gt;&lt;/script&gt;</code></pre>

<table>
    <tr>
        <th>Switch</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code><b>L_PREFER_CANVAS</b></code></td>
        <td>Forces Leaflet to use the Canvas back-end (if available) for vector layers instead of SVG. This can increase performance considerably in some cases (e.g. many thousands of circle markers on the map).</td>
    </tr>
    <tr>
        <td><code><b>L_NO_TOUCH</b></code></td>
        <td>Forces Leaflet to not use touch events even if it detects them.</td>
    </tr>
    <tr>
        <td><code><b>L_DISABLE_3D</b></code></td>
        <td>Forces Leaflet to not use hardware-accelerated CSS 3D transforms for positioning (which may cause glitches in some rare environments) even if they're supported.</td>
    </tr>
</table>

<h2 id="noconflict">L.noConflict()</h2>

<p>This method restores the L global variable to the original value it had before Leaflet inclusion, and returns the real Leaflet namespace so you can put it elsewhere, like this:<p>

<pre><code>// L points to some other library
    ...
    // you include Leaflet, it replaces the L variable to Leaflet namespace

    var Leaflet = L.noConflict();
    // now L points to that other library again, and you can use Leaflet.Map etc.</code></pre>


<h2 id="version">L.version</h2>

<p>显示当前使用的 Leaflet 版本的常量。<p>

<pre><code>L.version // returns "0.1" (or whatever version is currently in use)</code></pre>


</div>

</body>
</html>
